#!/bin/bash
# PHP Version Manager (PHPVM) v__VERSION__
# https://github.com/professor93/phpvm
# This file is auto-generated. Do not edit directly.

set -o pipefail

# === config.sh ===

PHPVM_VERSION="__VERSION__"
PHPVM_REPO="professor93/phpvm"
PHPVM_GITHUB_API="https://api.github.com/repos/${PHPVM_REPO}/releases/latest"
PHPVM_RAW_URL="https://raw.githubusercontent.com/${PHPVM_REPO}/main"

GUM_GITHUB_REPO="charmbracelet/gum"
GUM_MIN_VERSION="0.13.0"

PHPVM_BIN_DIR="/usr/local/bin"
PHPVM_ENV_FILE="/etc/profile.d/phpvm.sh"
PHPVM_BIN_DIR_USER="$HOME/.local/bin"
PHPVM_ENV_FILE_USER="$HOME/.config/phpvm/env.sh"

PHPVM_DIR="$HOME/.phpvm"
PHPVM_CONFIG="$PHPVM_DIR/version"
SYSTEM_CONFIG="/etc/phpvm/version"

SUPPORTED_VERSIONS=("8.5" "8.4" "8.3" "8.2" "8.1" "8.0" "7.4" "7.3" "7.2" "7.1" "7.0" "5.6")

DEFAULT_EXTENSIONS=(
    "curl" "mbstring" "xml" "zip" "bcmath" "intl" "pdo" "sqlite3" "opcache"
)

LOG_TIMESTAMPS=true  # Enable timestamps in verbose/log output
LOG_FILE="$HOME/.phpvm/phpvm.log"

# === colors.sh ===

setup_colors() {
    if [[ -t 1 ]]; then
        RED=$(tput setaf 1 2>/dev/null || echo '')
        GREEN=$(tput setaf 2 2>/dev/null || echo '')
        YELLOW=$(tput setaf 3 2>/dev/null || echo '')
        BLUE=$(tput setaf 4 2>/dev/null || echo '')
        CYAN=$(tput setaf 6 2>/dev/null || echo '')
        MAGENTA=$(tput setaf 5 2>/dev/null || echo '')
        BOLD=$(tput bold 2>/dev/null || echo '')
        DIM=$(tput dim 2>/dev/null || echo '')
        RESET=$(tput sgr0 2>/dev/null || echo '')
    else
        RED="" GREEN="" YELLOW="" BLUE="" CYAN="" MAGENTA="" BOLD="" DIM="" RESET=""
    fi
}

# === utils.sh ===

timestamp() {
    date "+%Y-%m-%d %H:%M:%S"
}

msg() {
    echo "${GREEN}→${RESET} $*"
}

warn() {
    echo "${YELLOW}⚠${RESET} $*"
}

error() {
    echo "${RED}✗${RESET} $*" >&2
}

success() {
    echo "${GREEN}✓${RESET} $*"
}

log() {
    local level="$1"
    shift
    if [[ "$LOG_TIMESTAMPS" == "true" ]]; then
        echo "[$(timestamp)] [$level] $*" >> "$LOG_FILE" 2>/dev/null
    fi
}

info_log() {
    local msg="$*"
    if [[ "$LOG_TIMESTAMPS" == "true" ]]; then
        echo "${DIM}[$(timestamp)]${RESET} ${CYAN}ℹ${RESET} $msg"
    else
        echo "${CYAN}ℹ${RESET} $msg"
    fi
    log "INFO" "$msg"
}

run_privileged() {
    if [[ $EUID -eq 0 ]]; then
        "$@"
    else
        sudo "$@"
    fi
}

check_sudo() {
    if [[ $EUID -ne 0 ]]; then
        if ! sudo -v &>/dev/null; then
            error "This operation requires sudo privileges"
            exit 1
        fi
    fi
}

init_phpvm() {
    mkdir -p "$PHPVM_DIR"
    touch "$LOG_FILE" 2>/dev/null || true
}

command_exists() {
    command -v "$1" &>/dev/null
}

version_gte() {
    printf '%s\n%s\n' "$2" "$1" | sort -V -C
}

validate_version_format() {
    local version="$1"
    if [[ ! "$version" =~ ^[0-9]+\.[0-9]+$ ]]; then
        error "Invalid version format: $version"
        echo "Version must be in format X.Y (e.g., 8.4)"
        return 1
    fi
}

is_supported_version() {
    local version="$1"
    for v in "${SUPPORTED_VERSIONS[@]}"; do
        [[ "$v" == "$version" ]] && return 0
    done
    return 1
}

# === platform.sh ===

detect_distro() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        DISTRO_ID="${ID:-unknown}"
        DISTRO_ID_LIKE="${ID_LIKE:-}"
        DISTRO_VERSION="${VERSION_ID:-}"
        DISTRO_NAME="${PRETTY_NAME:-$ID}"
    elif [[ -f /etc/redhat-release ]]; then
        DISTRO_ID="rhel"
        DISTRO_NAME=$(cat /etc/redhat-release)
    elif [[ -f /etc/debian_version ]]; then
        DISTRO_ID="debian"
        DISTRO_NAME="Debian $(cat /etc/debian_version)"
    else
        DISTRO_ID="unknown"
        DISTRO_NAME="Unknown Linux"
    fi

    # Detect WSL
    IS_WSL=false
    if grep -qi microsoft /proc/version 2>/dev/null; then
        IS_WSL=true
    fi
}

get_package_manager() {
    case "$DISTRO_ID" in
        ubuntu|debian|linuxmint|pop)
            echo "apt"
            ;;
        fedora|rhel|centos|rocky|alma|ol)
            if command_exists dnf; then
                echo "dnf"
            else
                echo "yum"
            fi
            ;;
        opensuse*|sles)
            echo "zypper"
            ;;
        arch|manjaro)
            echo "pacman"
            ;;
        *)
            # Check by ID_LIKE
            if [[ "$DISTRO_ID_LIKE" == *"debian"* ]] || [[ "$DISTRO_ID_LIKE" == *"ubuntu"* ]]; then
                echo "apt"
            elif [[ "$DISTRO_ID_LIKE" == *"rhel"* ]] || [[ "$DISTRO_ID_LIKE" == *"fedora"* ]]; then
                command_exists dnf && echo "dnf" || echo "yum"
            else
                echo "unknown"
            fi
            ;;
    esac
}

get_php_package_prefix() {
    local pm=$(get_package_manager)
    case "$pm" in
        apt)
            echo "php"  # php8.4, php8.4-cli, etc.
            ;;
        dnf|yum)
            echo "php"  # php84, php84-cli, etc. (Remi format)
            ;;
        *)
            echo "php"
            ;;
    esac
}

get_php_binary_path() {
    local version="$1"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            echo "/usr/bin/php${version}"
            ;;
        dnf|yum)
            # Remi installs as php (managed by alternatives) or /usr/bin/phpXY
            local v_nodot="${version//./}"
            if [[ -x "/usr/bin/php${v_nodot}" ]]; then
                echo "/usr/bin/php${v_nodot}"
            elif [[ -x "/opt/remi/php${v_nodot}/root/usr/bin/php" ]]; then
                echo "/opt/remi/php${v_nodot}/root/usr/bin/php"
            else
                echo "/usr/bin/php${version}"
            fi
            ;;
        *)
            echo "/usr/bin/php${version}"
            ;;
    esac
}

check_php_repository() {
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            # Check for Ondrej's PPA
            if ls /etc/apt/sources.list.d/*ondrej* &>/dev/null || \
               grep -r "ondrej/php" /etc/apt/sources.list.d/ &>/dev/null; then
                return 0
            fi
            return 1
            ;;
        dnf|yum)
            # Check for Remi repository
            if [[ -f /etc/yum.repos.d/remi.repo ]] || \
               [[ -f /etc/yum.repos.d/remi-php*.repo ]] || \
               dnf repolist 2>/dev/null | grep -qi remi; then
                return 0
            fi
            return 1
            ;;
        *)
            return 1
            ;;
    esac
}

setup_php_repository() {
    local pm=$(get_package_manager)

    info_log "Setting up PHP repository for $DISTRO_NAME..."

    case "$pm" in
        apt)
            run_privileged apt-get update -qq
            run_privileged apt-get install -y software-properties-common
            run_privileged add-apt-repository -y ppa:ondrej/php
            run_privileged apt-get update -qq
            success "Ondrej's PHP PPA configured"
            ;;
        dnf)
            # Fedora
            if [[ "$DISTRO_ID" == "fedora" ]]; then
                run_privileged dnf install -y "https://rpms.remirepo.net/fedora/remi-release-${DISTRO_VERSION}.rpm"
            # RHEL/CentOS/Rocky/Alma
            else
                run_privileged dnf install -y epel-release
                run_privileged dnf install -y "https://rpms.remirepo.net/enterprise/remi-release-${DISTRO_VERSION%%.*}.rpm"
            fi
            success "Remi repository configured"
            ;;
        yum)
            run_privileged yum install -y epel-release
            run_privileged yum install -y "https://rpms.remirepo.net/enterprise/remi-release-${DISTRO_VERSION%%.*}.rpm"
            success "Remi repository configured"
            ;;
        *)
            error "Unsupported package manager: $pm"
            echo ""
            echo "Please manually configure a PHP repository for your distribution."
            echo ""
            echo "Supported repositories:"
            echo "  - Ubuntu/Debian: ppa:ondrej/php"
            echo "  - RHEL/CentOS/Fedora: https://rpms.remirepo.net/"
            return 1
            ;;
    esac
}

check_php_available() {
    local version="$1"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            apt-cache show "php${version}" &>/dev/null
            ;;
        dnf)
            local v_nodot="${version//./}"
            dnf info "php${v_nodot}" &>/dev/null 2>&1 || \
            dnf info "php${v_nodot}-php-cli" &>/dev/null 2>&1
            ;;
        yum)
            local v_nodot="${version//./}"
            yum info "php${v_nodot}" &>/dev/null 2>&1
            ;;
        *)
            return 1
            ;;
    esac
}

install_php_base() {
    local version="$1"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            # Install php-cli directly to avoid pulling in Apache
            run_privileged apt-get install -y "php${version}-cli"
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            # Enable Remi module for this PHP version
            if [[ "$pm" == "dnf" ]]; then
                run_privileged dnf module reset php -y 2>/dev/null || true
                run_privileged dnf module enable "php:remi-${version}" -y 2>/dev/null || true
            fi
            run_privileged $pm install -y "php${v_nodot}-php-cli"
            ;;
    esac
}

install_php_extension() {
    local version="$1"
    local ext="$2"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            run_privileged apt-get install -y "php${version}-${ext}"
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            run_privileged $pm install -y "php${v_nodot}-php-${ext}"
            ;;
    esac
}

get_available_extensions() {
    local version="$1"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            apt-cache search "^php${version}-" 2>/dev/null | sed "s/php${version}-//" | cut -d' ' -f1 | sort
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            $pm list available "php${v_nodot}-php-*" 2>/dev/null | grep -v "^Last" | awk '{print $1}' | sed "s/php${v_nodot}-php-//" | cut -d'.' -f1 | sort -u
            ;;
    esac
}

get_installed_extensions() {
    local version="$1"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            dpkg -l "php${version}-*" 2>/dev/null | grep "^ii" | awk '{print $2}' | sed "s/:.*//; s/php${version}-//"
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            $pm list installed "php${v_nodot}-php-*" 2>/dev/null | grep -v "^Installed" | awk '{print $1}' | sed "s/php${v_nodot}-php-//" | cut -d'.' -f1
            ;;
    esac
}

uninstall_php_package() {
    local version="$1"
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            run_privileged apt-get remove -y "php${version}*"
            run_privileged apt-get autoremove -y
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            run_privileged $pm remove -y "php${v_nodot}*"
            ;;
    esac
}

get_installed_versions_platform() {
    local pm=$(get_package_manager)
    local versions=()

    case "$pm" in
        apt)
            # Check for /usr/bin/phpX.Y binaries
            for v in "${SUPPORTED_VERSIONS[@]}"; do
                [[ -x "/usr/bin/php${v}" ]] && versions+=("$v")
            done
            ;;
        dnf|yum)
            # Check for Remi PHP installations
            for v in "${SUPPORTED_VERSIONS[@]}"; do
                local v_nodot="${v//./}"
                if [[ -x "/usr/bin/php${v_nodot}" ]] || \
                   [[ -x "/opt/remi/php${v_nodot}/root/usr/bin/php" ]]; then
                    versions+=("$v")
                fi
            done
            ;;
    esac

    echo "${versions[@]}"
}

# === ui.sh ===

check_gum() {
    if ! command_exists gum; then
        return 1
    fi

    local current_version
    current_version=$(gum --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

    if [[ -z "$current_version" ]]; then
        return 1
    fi

    version_gte "$current_version" "$GUM_MIN_VERSION"
}

install_gum_github() {
    local arch
    case "$(uname -m)" in
        x86_64)  arch="amd64" ;;
        aarch64) arch="arm64" ;;
        armv7l)  arch="armv7" ;;
        *)       return 1 ;;
    esac

    info_log "Installing gum from GitHub releases..."

    local tmp_dir
    tmp_dir=$(mktemp -d)
    local latest_url="https://api.github.com/repos/${GUM_GITHUB_REPO}/releases/latest"

    # Get latest release info
    local release_json
    release_json=$(curl -fsSL "$latest_url")

    if [[ -z "$release_json" ]]; then
        rm -rf "$tmp_dir"
        return 1
    fi

    # Try to find download URL - different naming patterns:
    # .deb: gum_VERSION_ARCH.deb (e.g., gum_0.17.0_amd64.deb)
    # .rpm: gum_VERSION_ARCH.rpm
    # .tar.gz: gum_VERSION_Linux_ARCH.tar.gz
    local download_url
    local pm=$(get_package_manager 2>/dev/null)

    case "$pm" in
        apt)
            # Prefer .deb for Debian/Ubuntu
            download_url=$(echo "$release_json" | grep -oE "https://[^\"]+_${arch}\.deb" | head -1)
            ;;
        dnf|yum)
            # Prefer .rpm for RHEL/Fedora
            download_url=$(echo "$release_json" | grep -oE "https://[^\"]+_${arch}\.rpm" | head -1)
            ;;
    esac

    # Fallback to tar.gz if no package found
    if [[ -z "$download_url" ]]; then
        # For tar.gz, arch mapping might differ (x86_64 vs amd64)
        local tar_arch="$arch"
        [[ "$arch" == "amd64" ]] && tar_arch="x86_64"
        download_url=$(echo "$release_json" | grep -oE "https://[^\"]+Linux_${tar_arch}\.tar\.gz" | head -1)
    fi

    if [[ -z "$download_url" ]]; then
        warn "Could not find gum release for $arch"
        rm -rf "$tmp_dir"
        return 1
    fi

    local filename="${download_url##*/}"

    if ! curl -fsSL -o "${tmp_dir}/${filename}" "$download_url"; then
        rm -rf "$tmp_dir"
        return 1
    fi

    # Install based on file type
    case "$filename" in
        *.deb)
            run_privileged dpkg -i "${tmp_dir}/${filename}"
            ;;
        *.rpm)
            run_privileged rpm -i "${tmp_dir}/${filename}"
            ;;
        *.tar.gz)
            tar -xzf "${tmp_dir}/${filename}" -C "$tmp_dir"
            local gum_bin=$(find "$tmp_dir" -name "gum" -type f -executable | head -1)
            if [[ -n "$gum_bin" ]]; then
                run_privileged install -m 755 "$gum_bin" /usr/local/bin/gum
            else
                rm -rf "$tmp_dir"
                return 1
            fi
            ;;
    esac

    rm -rf "$tmp_dir"

    if check_gum; then
        success "gum installed successfully"
        return 0
    fi
    return 1
}

install_gum_package_manager() {
    local pm=$(get_package_manager)

    info_log "Installing gum from package manager..."

    case "$pm" in
        apt)
            # Try to add charm repository
            if ! grep -q "charm.sh" /etc/apt/sources.list.d/* 2>/dev/null; then
                run_privileged mkdir -p /etc/apt/keyrings
                curl -fsSL https://repo.charm.sh/apt/gpg.key | run_privileged gpg --dearmor -o /etc/apt/keyrings/charm.gpg
                echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | \
                    run_privileged tee /etc/apt/sources.list.d/charm.list
                run_privileged apt-get update -qq
            fi
            run_privileged apt-get install -y gum
            ;;
        dnf|yum)
            # Try Charm's rpm repository
            echo '[charm]
name=Charm
baseurl=https://repo.charm.sh/yum/
enabled=1
gpgcheck=1
gpgkey=https://repo.charm.sh/yum/gpg.key' | run_privileged tee /etc/yum.repos.d/charm.repo
            run_privileged $pm install -y gum
            ;;
        *)
            return 1
            ;;
    esac

    check_gum
}

ensure_gum() {
    if check_gum; then
        return 0
    fi

    warn "gum is not installed. Installing..."

    # Try GitHub releases first
    if install_gum_github; then
        return 0
    fi

    warn "GitHub installation failed. Trying package manager..."

    # Try package manager
    if install_gum_package_manager; then
        return 0
    fi

    warn "Could not install gum. Falling back to basic menu."
    return 1
}

UI_MODE="gum"  # gum, fallback

set_ui_mode() {
    if check_gum; then
        UI_MODE="gum"
    else
        UI_MODE="fallback"
    fi
}

print_header() {
    local current_version
    current_version=$(get_current_version)

    local header_text="PHP Version Manager v${PHPVM_VERSION}"
    local status_text

    if [[ -n "$current_version" ]]; then
        status_text="Current: PHP ${current_version}"

        # Add framework info if in a framework project
        local framework
        framework=$(detect_framework 2>/dev/null)
        if [[ -n "$framework" ]]; then
            local fw_name fw_version
            fw_name=$(get_framework_display_name "$framework")
            fw_version=$(get_framework_version "$framework" 2>/dev/null)
            if [[ -n "$fw_version" ]]; then
                status_text="${status_text} | ${fw_name} v${fw_version}"
            else
                status_text="${status_text} | ${fw_name}"
            fi
        fi
    else
        status_text="No PHP installed"
    fi

    if [[ "$UI_MODE" == "gum" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "0 2" \
            --margin "1 0" \
            "$header_text" \
            "$status_text"
    else
        echo ""
        echo "+-----------------------------------------------------------------+"
        printf "| %-63s |\n" "$header_text"
        printf "| %-63s |\n" "$status_text"
        echo "+-----------------------------------------------------------------+"
        echo ""
    fi
}

gum_menu() {
    local prompt="$1"
    shift
    local options=("$@")

    if [[ "$UI_MODE" == "gum" ]]; then
        printf '%s\n' "${options[@]}" | gum choose \
            --header "$prompt" \
            --cursor.foreground 212 \
            --header.foreground 99 \
            --selected.foreground 212
    else
        # Fallback: numbered menu
        # Output menu to stderr so only selection goes to stdout
        echo "" >&2
        echo "${CYAN}${prompt}${RESET}" >&2
        echo "" >&2

        local i=1
        for opt in "${options[@]}"; do
            echo "  ${YELLOW}${i})${RESET} $opt" >&2
            ((i++))
        done
        echo "" >&2

        local choice
        read -rp "Enter number (1-${#options[@]}): " choice

        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#options[@]} )); then
            echo "${options[$((choice-1))]}"
        else
            echo ""
        fi
    fi
}

gum_multi_menu() {
    local prompt="$1"
    shift
    local options=("$@")

    if [[ "$UI_MODE" == "gum" ]]; then
        # Get terminal dimensions
        local term_width term_height
        term_width=$(tput cols 2>/dev/null || echo 80)
        term_height=$(tput lines 2>/dev/null || echo 24)

        # Calculate filter height (leave room for header and input)
        local filter_height=$((term_height - 6))
        [[ $filter_height -gt 30 ]] && filter_height=30
        [[ $filter_height -lt 5 ]] && filter_height=5

        # Use full terminal width
        local filter_width=$((term_width - 2))
        [[ $filter_width -lt 40 ]] && filter_width=40

        printf '%s\n' "${options[@]}" | gum filter \
            --no-limit \
            --header "$prompt" \
            --header.foreground 99 \
            --indicator.foreground 212 \
            --match.foreground 212 \
            --height "$filter_height" \
            --width "$filter_width" \
            --placeholder "Type to filter, Tab to select, Enter to confirm"
    else
        # Fallback: multi-column display
        # Output menu to stderr so only selection goes to stdout
        echo "" >&2
        echo "${CYAN}${prompt}${RESET}" >&2
        echo "" >&2

        # Calculate columns based on terminal width
        local term_width
        term_width=$(tput cols 2>/dev/null || echo 80)

        # Find max option length
        local max_len=0
        for opt in "${options[@]}"; do
            [[ ${#opt} -gt $max_len ]] && max_len=${#opt}
        done

        # Column width = number prefix (4) + option + padding (2)
        local col_width=$((max_len + 6))
        local num_cols=$((term_width / col_width))
        [[ $num_cols -lt 1 ]] && num_cols=1
        [[ $num_cols -gt 4 ]] && num_cols=4

        # Print options in columns
        local i=1
        local col=0
        for opt in "${options[@]}"; do
            printf "${YELLOW}%3d)${RESET} %-${max_len}s  " "$i" "$opt" >&2
            ((col++))
            ((i++))
            if [[ $col -ge $num_cols ]]; then
                echo "" >&2
                col=0
            fi
        done
        [[ $col -ne 0 ]] && echo "" >&2
        echo "" >&2

        local choices
        read -rp "Enter numbers separated by comma (e.g., 1,3,5): " choices

        IFS=',' read -ra selected <<< "$choices"
        for num in "${selected[@]}"; do
            num=$(echo "$num" | tr -d ' ')
            if [[ "$num" =~ ^[0-9]+$ ]] && (( num >= 1 && num <= ${#options[@]} )); then
                echo "${options[$((num-1))]}"
            fi
        done
    fi
}

gum_confirm() {
    local prompt="$1"
    local default="${2:-yes}"  # yes or no

    if [[ "$UI_MODE" == "gum" ]]; then
        if [[ "$default" == "yes" ]]; then
            gum confirm --default=yes "$prompt"
        else
            gum confirm --default=no "$prompt"
        fi
    else
        local yn
        if [[ "$default" == "yes" ]]; then
            read -rp "${prompt} [Y/n]: " yn
            yn="${yn:-y}"
        else
            read -rp "${prompt} [y/N]: " yn
            yn="${yn:-n}"
        fi

        case "$yn" in
            [Yy]*) return 0 ;;
            *) return 1 ;;
        esac
    fi
}

gum_input() {
    local prompt="$1"
    local default="${2:-}"
    local placeholder="${3:-}"

    if [[ "$UI_MODE" == "gum" ]]; then
        gum input \
            --prompt "$prompt " \
            --value "$default" \
            --placeholder "$placeholder"
    else
        local input
        if [[ -n "$default" ]]; then
            read -rp "${prompt} [$default]: " input
            echo "${input:-$default}"
        else
            read -rp "${prompt}: " input
            echo "$input"
        fi
    fi
}

gum_spin() {
    local title="$1"
    shift

    # Check if the first argument is a shell function
    # gum spin runs commands in a subprocess which can't access shell functions
    local cmd="$1"
    local is_function=false
    if [[ "$(type -t "$cmd" 2>/dev/null)" == "function" ]]; then
        is_function=true
    fi

    if [[ "$UI_MODE" == "gum" && "$is_function" == "false" ]]; then
        gum spin --spinner dot --title "$title" -- "$@"
    else
        echo "${CYAN}${title}...${RESET}"
        "$@"
    fi
}

gum_format() {
    local text="$1"
    local type="${2:-}"  # markdown, code, template

    if [[ "$UI_MODE" == "gum" ]]; then
        case "$type" in
            markdown) echo "$text" | gum format ;;
            code) echo "$text" | gum format -t code ;;
            *) echo "$text" ;;
        esac
    else
        echo "$text"
    fi
}


ui_read_key() {
    local key
    IFS= read -rsn1 key 2>/dev/null

    # Handle escape sequences (arrow keys, function keys)
    if [[ "$key" == $'\x1b' ]]; then
        read -rsn2 -t 0.1 key2 2>/dev/null
        key+="$key2"
    fi

    echo "$key"
}

hotkey_menu() {
    local header="$1"
    shift
    local options=("$@")
    local count=${#options[@]}

    echo ""
    echo "${BOLD}${CYAN}$header${RESET}"
    echo ""

    local i=1
    for opt in "${options[@]}"; do
        if [[ $i -le 9 ]]; then
            echo "  ${YELLOW}[$i]${RESET} $opt"
        else
            local letter
            letter=$(printf "\\x$(printf '%02x' $((96 + i - 9)))")  # a, b, c...
            echo "  ${YELLOW}[$letter]${RESET} $opt"
        fi
        ((i++))
    done

    echo ""
    echo "  ${YELLOW}[0]${RESET} Cancel"
    echo ""
    echo "${DIM}Press key to select${RESET}"

    local key
    key=$(ui_read_key)

    case "$key" in
        $'\x03'|0|q|Q|\x1b)  # Ctrl-C, 0, q, Escape
            return 1
            ;;
        [1-9])
            local idx=$((key - 1))
            if [[ $idx -lt $count ]]; then
                echo "${options[$idx]}"
                return 0
            fi
            ;;
        [a-z])
            local idx=$(($(printf '%d' "'$key") - 97 + 9))
            if [[ $idx -lt $count ]]; then
                echo "${options[$idx]}"
                return 0
            fi
            ;;
    esac

    return 1
}

hotkey_confirm_yesno() {
    local question="$1"
    local default="${2:-yes}"  # yes or no

    echo ""
    echo "$question"

    if [[ "$default" == "yes" ]]; then
        echo "  ${YELLOW}[Y]${RESET} Yes (default)"
        echo "  ${YELLOW}[n]${RESET} No"
    else
        echo "  ${YELLOW}[y]${RESET} Yes"
        echo "  ${YELLOW}[N]${RESET} No (default)"
    fi
    echo ""

    local key
    key=$(ui_read_key)

    case "$key" in
        y|Y) return 0 ;;
        n|N) return 1 ;;
        "")  # Enter key
            [[ "$default" == "yes" ]] && return 0 || return 1
            ;;
        $'\x03'|\x1b)  # Ctrl-C, Escape
            return 1
            ;;
        *)
            [[ "$default" == "yes" ]] && return 0 || return 1
            ;;
    esac
}

show_key_hint() {
    local hint="$1"
    echo "${DIM}$hint${RESET}"
}

wait_any_key() {
    local msg="${1:-Press any key to continue...}"
    echo ""
    echo "${DIM}$msg${RESET}"
    read -rsn1
}

paginate_show() {
    local -n items=$1
    local page_size=${2:-10}
    local page=${3:-1}

    local total=${#items[@]}
    local total_pages=$(( (total + page_size - 1) / page_size ))
    local start=$(( (page - 1) * page_size ))
    local end=$(( start + page_size ))
    [[ $end -gt $total ]] && end=$total

    local i=$start
    local num=1
    while [[ $i -lt $end ]]; do
        if [[ $num -le 9 ]]; then
            echo "  ${YELLOW}[$num]${RESET} ${items[$i]}"
        else
            echo "      ${items[$i]}"
        fi
        ((i++))
        ((num++))
    done

    echo ""
    echo "${DIM}Page $page/$total_pages | [n]ext [p]rev [q]uit${RESET}"
}

# === version.sh ===

get_installed_versions() {
    get_installed_versions_platform
}

find_phpversion_file() {
    local dir="$PWD"
    local home_dir="$HOME"

    while [[ "$dir" != "/" && "$dir" != "$home_dir" ]]; do
        if [[ -f "${dir}/.phpversion" ]]; then
            echo "${dir}/.phpversion"
            return 0
        fi
        dir=$(dirname "$dir")
    done

    # Check home directory itself (but not root /)
    if [[ -f "${home_dir}/.phpversion" && "$home_dir" != "/" ]]; then
        echo "${home_dir}/.phpversion"
        return 0
    fi

    return 1
}

find_phpversion_dir() {
    local file
    file=$(find_phpversion_file) || return 1
    dirname "$file"
}

get_current_version() {
    local version=""

    # 1. PHPVERSION_USE env var (session)
    if [[ -n "${PHPVERSION_USE:-}" ]]; then
        version="$PHPVERSION_USE"
    # 2. .phpversion file (local - searches up from $PWD)
    elif local file; file=$(find_phpversion_file) 2>/dev/null; then
        version=$(cat "$file" 2>/dev/null | tr -d '[:space:]')
    # 3. ~/.phpvm/version (user default)
    elif [[ -f "$PHPVM_CONFIG" ]]; then
        version=$(cat "$PHPVM_CONFIG" 2>/dev/null | tr -d '[:space:]')
    # 4. /etc/phpvm/version (system default)
    elif [[ -f "$SYSTEM_CONFIG" ]]; then
        version=$(cat "$SYSTEM_CONFIG" 2>/dev/null | tr -d '[:space:]')
    # 5. First installed version (fallback)
    else
        local installed
        installed=($(get_installed_versions))
        if [[ ${#installed[@]} -gt 0 ]]; then
            version="${installed[0]}"
        fi
    fi

    # Validate the version is actually installed
    if [[ -n "$version" ]]; then
        local php_bin
        php_bin=$(get_php_binary_path "$version")
        if [[ -x "$php_bin" ]]; then
            echo "$version"
            return 0
        fi
    fi

    # If configured version not installed, fall back to first installed
    local installed
    installed=($(get_installed_versions))
    if [[ ${#installed[@]} -gt 0 ]]; then
        echo "${installed[0]}"
    fi
}

get_version_source() {
    # 1. PHPVERSION_USE env var (session)
    if [[ -n "${PHPVERSION_USE:-}" ]]; then
        echo "session (PHPVERSION_USE=${PHPVERSION_USE})"
        return
    fi

    # 2. .phpversion file (local)
    local file
    if file=$(find_phpversion_file) 2>/dev/null; then
        echo "local (${file})"
        return
    fi

    # 3. ~/.phpvm/version (user default)
    if [[ -f "$PHPVM_CONFIG" ]]; then
        echo "user (~/.phpvm/version)"
        return
    fi

    # 4. /etc/phpvm/version (system default)
    if [[ -f "$SYSTEM_CONFIG" ]]; then
        echo "system (/etc/phpvm/version)"
        return
    fi

    # 5. First installed version (fallback)
    echo "fallback (first installed)"
}

get_php_binary() {
    local version="${1:-$(get_current_version)}"

    if [[ -z "$version" ]]; then
        return 1
    fi

    local php_bin
    php_bin=$(get_php_binary_path "$version")

    if [[ -x "$php_bin" ]]; then
        echo "$php_bin"
        return 0
    fi

    return 1
}

get_full_php_version() {
    local version="${1:-$(get_current_version)}"
    local php_bin
    php_bin=$(get_php_binary "$version") || return 1

    "$php_bin" -r 'echo PHP_VERSION;' 2>/dev/null
}

# === framework.sh ===

detect_framework() {
    local dir="${1:-$PWD}"

    # Laravel: has artisan file
    if [[ -f "$dir/artisan" ]]; then
        echo "laravel"
        return 0
    fi

    # Symfony: has bin/console or symfony.lock
    if [[ -f "$dir/bin/console" ]] || [[ -f "$dir/symfony.lock" ]]; then
        echo "symfony"
        return 0
    fi

    # Yii2: has yii file
    if [[ -f "$dir/yii" ]]; then
        echo "yii"
        return 0
    fi

    return 1
}

is_framework_project() {
    [[ -n "$(detect_framework)" ]]
}

get_project_name() {
    local dir="${1:-$PWD}"

    if [[ -f "$dir/composer.json" ]]; then
        local name
        name=$(grep -oE '"name"\s*:\s*"[^"]+"' "$dir/composer.json" 2>/dev/null | head -1 | cut -d'"' -f4)
        if [[ -n "$name" ]]; then
            echo "$name"
            return
        fi
    fi

    # Fallback to directory name
    basename "$dir"
}

get_console_command() {
    local framework="${1:-$(detect_framework)}"
    local dir="${2:-$PWD}"

    case "$framework" in
        laravel)  echo "$dir/artisan" ;;
        symfony)  echo "$dir/bin/console" ;;
        yii)      echo "$dir/yii" ;;
    esac
}

get_serve_command() {
    local framework="${1:-$(detect_framework)}"

    case "$framework" in
        laravel)  echo "artisan serve" ;;
        symfony)  echo "bin/console server:start" ;;
        yii)      echo "yii serve" ;;
    esac
}

get_queue_command() {
    local framework="${1:-$(detect_framework)}"

    case "$framework" in
        laravel)  echo "artisan queue:work" ;;
        symfony)  echo "bin/console messenger:consume" ;;
        yii)      echo "yii queue/listen" ;;
    esac
}

get_scheduler_command() {
    local framework="${1:-$(detect_framework)}"

    case "$framework" in
        laravel)  echo "artisan schedule:run" ;;
        symfony)  echo "bin/console scheduler:run" ;;
        yii)      echo "yii schedule/run" ;;
    esac
}

has_horizon() {
    local dir="${1:-$PWD}"
    [[ -f "$dir/composer.json" ]] && grep -q '"laravel/horizon"' "$dir/composer.json" 2>/dev/null
}

has_octane() {
    local dir="${1:-$PWD}"
    [[ -f "$dir/composer.json" ]] && grep -q '"laravel/octane"' "$dir/composer.json" 2>/dev/null
}

get_framework_commands() {
    local framework="${1:-$(detect_framework)}"
    local php_bin="${2:-php}"

    case "$framework" in
        laravel)
            "$php_bin" artisan list --format=txt 2>/dev/null | grep -E '^\s+\w+' | awk '{print $1}'
            ;;
        symfony)
            "$php_bin" bin/console list --format=txt 2>/dev/null | grep -E '^\s+\w+' | awk '{print $1}'
            ;;
        yii)
            "$php_bin" yii help 2>/dev/null | grep -E '^\s+-\s+' | awk '{print $2}'
            ;;
    esac
}

get_project_id() {
    local dir="${1:-$PWD}"
    # Use hash of absolute path for uniqueness
    echo "phpvm_$(echo "$dir" | md5sum | cut -c1-8)"
}

get_framework_display_name() {
    local framework="${1:-$(detect_framework)}"

    case "$framework" in
        laravel)  echo "Laravel" ;;
        symfony)  echo "Symfony" ;;
        yii)      echo "Yii2" ;;
        *)        echo "PHP" ;;
    esac
}

get_framework_version() {
    local framework="${1:-$(detect_framework)}"
    local dir="${2:-$PWD}"
    local lock_file="$dir/composer.lock"

    [[ ! -f "$lock_file" ]] && return

    local package_name
    case "$framework" in
        laravel)  package_name="laravel/framework" ;;
        symfony)  package_name="symfony/framework-bundle" ;;
        yii)      package_name="yiisoft/yii2" ;;
        *)        return ;;
    esac

    # Extract version from composer.lock
    grep -A5 "\"name\": \"$package_name\"" "$lock_file" 2>/dev/null | \
        grep '"version"' | head -1 | \
        sed 's/.*"version"[^"]*"\([^"]*\)".*/\1/' | \
        sed 's/^v//'
}

# === install.sh ===

ensure_repository() {
    if ! check_php_repository; then
        warn "PHP repository not configured"

        if gum_confirm "Would you like to set up the PHP repository?"; then
            setup_php_repository || return 1
        else
            error "Cannot install PHP without repository"
            echo ""
            echo "Manual setup instructions:"
            local pm=$(get_package_manager)
            case "$pm" in
                apt)
                    echo "  sudo add-apt-repository ppa:ondrej/php"
                    echo "  sudo apt-get update"
                    ;;
                dnf|yum)
                    echo "  sudo dnf install https://rpms.remirepo.net/enterprise/remi-release-\$(rpm -E %rhel).rpm"
                    echo "  # Or for Fedora:"
                    echo "  sudo dnf install https://rpms.remirepo.net/fedora/remi-release-\$(rpm -E %fedora).rpm"
                    ;;
            esac
            return 1
        fi
    fi
    return 0
}

cmd_install() {
    local requested_version="$1"

    ensure_repository || return 1

    if [[ -n "$requested_version" ]]; then
        # Direct version install: php install 8.4
        validate_version_format "$requested_version" || return 1

        if ! is_supported_version "$requested_version"; then
            error "PHP $requested_version is not in the supported versions list"
            echo "Supported versions: ${SUPPORTED_VERSIONS[*]}"
            return 1
        fi

        # Check if already installed
        local php_bin
        php_bin=$(get_php_binary "$requested_version" 2>/dev/null)

        if [[ -n "$php_bin" && -x "$php_bin" ]]; then
            # Already installed - show options
            local action
            action=$(gum_menu "PHP $requested_version is already installed. What would you like to do?" \
                "Update" \
                "Install extensions" \
                "Uninstall" \
                "Cancel")

            case "$action" in
                "Update")
                    update_php_version "$requested_version"
                    ;;
                "Install extensions")
                    install_extension "$requested_version"
                    ;;
                "Uninstall")
                    uninstall_php_version "$requested_version"
                    ;;
                *)
                    msg "Cancelled"
                    ;;
            esac
        else
            # Not installed - install it
            install_new_php_version "$requested_version"
        fi
    else
        # Interactive install
        local choice
        choice=$(gum_menu "What would you like to install?" \
            "PHP Version" \
            "Extension (for current PHP)")

        case "$choice" in
            "PHP Version")
                install_php_version_interactive
                ;;
            "Extension"*)
                local current
                current=$(get_current_version)
                if [[ -z "$current" ]]; then
                    error "No PHP version installed"
                    echo "Run 'php install' to install a PHP version first"
                    return 1
                fi
                install_extension "$current"
                ;;
            *)
                msg "Cancelled"
                ;;
        esac
    fi
}

show_failed_extensions() {
    local version="$1"
    shift
    local failed=("$@")

    if [[ ${#failed[@]} -eq 0 ]]; then
        return 0
    fi

    echo ""
    warn "The following extensions failed to install:"
    echo ""

    if [[ "$UI_MODE" == "gum" ]]; then
        printf '%s\n' "${failed[@]}" | gum format
    else
        for ext in "${failed[@]}"; do
            echo "  - php${version}-${ext}"
        done
    fi

    echo ""
    return 1
}

install_new_php_version() {
    local version="$1"

    info_log "Checking package availability for PHP $version..."

    if ! check_php_available "$version"; then
        error "PHP $version is not available in the repository"
        echo ""
        echo "This could mean:"
        echo "  - The version is not yet released"
        echo "  - The version is no longer supported"
        echo "  - The repository needs to be updated"
        echo ""
        echo "Try running: sudo apt-get update (or sudo dnf check-update)"
        return 1
    fi

    info_log "Installing PHP $version..."
    echo ""

    # Install base PHP first
    msg "Installing PHP $version base package..."
    if ! install_php_base "$version"; then
        error "Failed to install PHP $version base package"
        return 1
    fi
    success "PHP $version base installed"

    # Install default extensions one by one, collect failures
    local failed_extensions=()

    for ext in "${DEFAULT_EXTENSIONS[@]}"; do
        msg "Installing php${version}-${ext}..."
        if ! install_php_extension "$version" "$ext"; then
            failed_extensions+=("$ext")
        else
            success "php${version}-${ext} installed"
        fi
    done

    echo ""
    success "PHP $version installation completed"

    # Show failed extensions if any
    show_failed_extensions "$version" "${failed_extensions[@]}"

    # Validate installation
    local php_bin
    php_bin=$(get_php_binary "$version")

    if [[ -z "$php_bin" || ! -x "$php_bin" ]]; then
        warn "PHP $version was installed but binary not found at expected location"
        warn "You may need to configure your PATH or check the installation"
    else
        local full_version
        full_version=$("$php_bin" -r 'echo PHP_VERSION;' 2>/dev/null)
        success "Verified: PHP $full_version is working"
    fi

    # Set as default if first installation
    local installed
    installed=($(get_installed_versions))

    if [[ ${#installed[@]} -eq 1 ]]; then
        info_log "Setting PHP $version as default (first installation)"
        mkdir -p "$PHPVM_DIR"
        echo "$version" > "$PHPVM_CONFIG"
    fi

    return 0
}

install_php_version_interactive() {
    local options=()
    local installed
    installed=($(get_installed_versions))

    for v in "${SUPPORTED_VERSIONS[@]}"; do
        local label="PHP $v"
        for inst in "${installed[@]}"; do
            if [[ "$inst" == "$v" ]]; then
                label="[INSTALLED] PHP $v"
                break
            fi
        done
        options+=("$label")
    done

    local choice
    choice=$(gum_menu "Select PHP version to install:" "${options[@]}")

    if [[ -z "$choice" ]]; then
        msg "Cancelled"
        return
    fi

    # Extract version from choice
    local version
    version=$(echo "$choice" | grep -oE '[0-9]+\.[0-9]+')

    if [[ "$choice" == "[INSTALLED]"* ]]; then
        local action
        action=$(gum_menu "PHP $version is already installed. What would you like to do?" \
            "Update" \
            "Install extensions" \
            "Uninstall" \
            "Cancel")

        case "$action" in
            "Update") update_php_version "$version" ;;
            "Install extensions") install_extension "$version" ;;
            "Uninstall") uninstall_php_version "$version" ;;
            *) msg "Cancelled" ;;
        esac
    else
        install_new_php_version "$version"
    fi
}

update_php_version() {
    local version="$1"
    local pm=$(get_package_manager)

    info_log "Updating PHP $version..."

    case "$pm" in
        apt)
            gum_spin "Updating PHP $version" run_privileged apt-get upgrade -y "php${version}*"
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            gum_spin "Updating PHP $version" run_privileged $pm update -y "php${v_nodot}*"
            ;;
    esac

    success "PHP $version updated"
}

uninstall_php_version() {
    local version="$1"

    if ! gum_confirm "Are you sure you want to uninstall PHP $version?" "no"; then
        msg "Cancelled"
        return
    fi

    info_log "Uninstalling PHP $version..."

    gum_spin "Removing PHP $version" uninstall_php_package "$version"

    success "PHP $version uninstalled"

    # Clean up config if this was the default
    if [[ -f "$PHPVM_CONFIG" ]]; then
        local configured
        configured=$(cat "$PHPVM_CONFIG" 2>/dev/null | tr -d '[:space:]')
        if [[ "$configured" == "$version" ]]; then
            rm -f "$PHPVM_CONFIG"
            info_log "Removed user default configuration"
        fi
    fi
}

install_extension() {
    local version="$1"

    info_log "Fetching available extensions for PHP $version..."

    # Get available and installed extensions using platform functions
    local available=()
    local installed_ext=()

    while IFS= read -r ext; do
        [[ -n "$ext" ]] && available+=("$ext")
    done < <(get_available_extensions "$version")

    while IFS= read -r ext; do
        [[ -n "$ext" ]] && installed_ext+=("$ext")
    done < <(get_installed_extensions "$version")

    if [[ ${#available[@]} -eq 0 ]]; then
        error "No extensions found for PHP $version"
        return 1
    fi

    # Build display options (only show not installed extensions)
    local options=()
    for ext in "${available[@]}"; do
        local is_installed=false
        for inst in "${installed_ext[@]}"; do
            if [[ "$inst" == "$ext" ]]; then
                is_installed=true
                break
            fi
        done
        if [[ "$is_installed" == "false" ]]; then
            options+=("$ext")
        fi
    done

    if [[ ${#options[@]} -eq 0 ]]; then
        info_log "All available extensions are already installed"
        return 0
    fi

    # Use multiselect menu
    local selected
    selected=$(gum_multi_menu "Select extensions to install for PHP $version:" "${options[@]}")

    if [[ -z "$selected" ]]; then
        msg "Cancelled"
        return
    fi

    echo ""

    # Install selected extensions one by one, collect failures
    local failed_extensions=()
    local success_count=0

    while IFS= read -r ext_name; do
        [[ -z "$ext_name" ]] && continue
        msg "Installing php${version}-${ext_name}..."
        if install_php_extension "$version" "$ext_name"; then
            success "php${version}-${ext_name} installed"
            ((success_count++))
        else
            failed_extensions+=("$ext_name")
        fi
    done <<< "$selected"

    echo ""

    # Show summary
    if [[ $success_count -gt 0 ]]; then
        success "$success_count extension(s) installed successfully"
    fi

    # Show failed extensions if any
    show_failed_extensions "$version" "${failed_extensions[@]}"
}

check_no_php_installed() {
    local installed
    installed=($(get_installed_versions))

    if [[ ${#installed[@]} -eq 0 ]]; then
        warn "No PHP versions installed"
        echo ""

        if gum_confirm "Would you like to install PHP now?"; then
            cmd_install
            return $?
        else
            echo "Run 'php install' when ready to install PHP"
            exit 1
        fi
    fi
}

# === use.sh ===

PHPVM_SESSION_FILE="${PHPVM_SESSION_FILE:-}"

cmd_use() {
    local requested_version="$1"

    # Check if any PHP installed
    local installed
    installed=($(get_installed_versions))

    if [[ ${#installed[@]} -eq 0 ]]; then
        warn "No PHP versions installed"
        if gum_confirm "Would you like to install PHP now?"; then
            cmd_install
        fi
        return
    fi

    local version

    if [[ -n "$requested_version" ]]; then
        # Version specified
        validate_version_format "$requested_version" || return 1

        # Check if installed
        local found=false
        for v in "${installed[@]}"; do
            [[ "$v" == "$requested_version" ]] && found=true && break
        done

        if [[ "$found" == "false" ]]; then
            warn "PHP $requested_version is not installed"
            if gum_confirm "Would you like to install PHP $requested_version?"; then
                install_new_php_version "$requested_version" || return 1
            else
                return 1
            fi
        fi

        version="$requested_version"
    else
        # Interactive selection
        local options=()
        local current
        current=$(get_current_version)

        for v in "${installed[@]}"; do
            local label="PHP $v"
            [[ "$v" == "$current" ]] && label="PHP $v <- current"
            options+=("$label")
        done

        local choice
        choice=$(gum_menu "Select PHP version:" "${options[@]}")

        if [[ -z "$choice" ]]; then
            msg "Cancelled"
            return
        fi

        version=$(echo "$choice" | grep -oE '[0-9]+\.[0-9]+')
    fi

    # Select scope
    local scope
    scope=$(gum_menu "Set PHP $version for:" \
        "This session only" \
        "This directory (local .phpversion)" \
        "This user (global default)" \
        "System-wide (all users)")

    case "$scope" in
        "This session only")
            set_session_version "$version"
            ;;
        "This directory"*)
            set_local_version "$version"
            ;;
        "This user"*)
            set_user_version "$version"
            ;;
        "System-wide"*)
            set_system_version "$version"
            ;;
        *)
            msg "Cancelled"
            ;;
    esac
}

set_session_version() {
    local version="$1"

    # If running interactively with session file, write to it
    if [[ -n "$PHPVM_SESSION_FILE" ]]; then
        echo "$version" > "$PHPVM_SESSION_FILE"
        success "PHP $version set for this session"
    else
        # Output marker for shell wrapper to detect
        echo "PHPVERSION_USE=$version"
        success "PHP $version set for this session"
        echo ""
        echo "${DIM}Note: Run 'source ~/.bashrc' or start a new terminal for changes to take effect${RESET}"
    fi
}

set_local_version() {
    local version="$1"
    local target_dir="$PWD"

    # Check if .phpversion exists in parent directories
    local existing_file
    existing_file=$(find_phpversion_file 2>/dev/null)

    if [[ -n "$existing_file" && "$(dirname "$existing_file")" != "$PWD" ]]; then
        local choice
        choice=$(gum_menu "Found existing .phpversion in parent directory. Create in:" \
            "Current directory ($PWD)" \
            "Existing location ($(dirname "$existing_file"))" \
            "Cancel")

        case "$choice" in
            "Current directory"*)
                target_dir="$PWD"
                ;;
            "Existing location"*)
                target_dir=$(dirname "$existing_file")
                ;;
            *)
                msg "Cancelled"
                return
                ;;
        esac
    fi

    # Don't allow in root or home directly (unless explicit)
    if [[ "$target_dir" == "/" ]]; then
        error "Cannot create .phpversion in root directory"
        return 1
    fi

    echo "$version" > "${target_dir}/.phpversion"
    success "PHP $version set for ${target_dir}"
    info_log "Created ${target_dir}/.phpversion"
}

set_user_version() {
    local version="$1"

    mkdir -p "$PHPVM_DIR"
    echo "$version" > "$PHPVM_CONFIG"
    success "PHP $version set as user default"
    info_log "Updated ~/.phpvm/version"
}

set_system_version() {
    local version="$1"

    check_sudo

    run_privileged tee "$SYSTEM_CONFIG" > /dev/null <<< "$version"
    success "PHP $version set as system-wide default"
    info_log "Updated /etc/phpvm/version"
}

# === list.sh ===

cmd_list() {
    local subcommand="$1"

    if [[ "$subcommand" == "extensions" ]]; then
        list_extensions
    else
        list_versions
    fi
}

list_versions() {
    local installed
    installed=($(get_installed_versions))

    if [[ ${#installed[@]} -eq 0 ]]; then
        warn "No PHP versions installed"
        echo "Run 'php install' to install a PHP version"
        return
    fi

    local current
    current=$(get_current_version)

    echo ""
    echo "${BOLD}Installed PHP Versions:${RESET}"
    echo ""

    for v in "${installed[@]}"; do
        local php_bin
        php_bin=$(get_php_binary "$v")
        local full_version
        full_version=$("$php_bin" -r 'echo PHP_VERSION;' 2>/dev/null)

        if [[ "$v" == "$current" ]]; then
            echo "  ${GREEN}->${RESET} ${BOLD}PHP ${v}${RESET} (${full_version}) ${GREEN}<- active${RESET}"
        else
            echo "    PHP ${v} (${full_version})"
        fi
    done

    echo ""
}

list_extensions() {
    local version
    version=$(get_current_version)

    if [[ -z "$version" ]]; then
        error "No PHP version active"
        return 1
    fi

    local php_bin
    php_bin=$(get_php_binary "$version")

    echo ""
    echo "${BOLD}Extensions for PHP ${version}:${RESET}"
    echo ""

    echo "${CYAN}Loaded extensions (php -m):${RESET}"
    "$php_bin" -m 2>/dev/null | grep -v "^\[" | sort | while read -r ext; do
        echo "  * $ext"
    done

    echo ""
    echo "${CYAN}Installed packages:${RESET}"

    local pm=$(get_package_manager)
    case "$pm" in
        apt)
            dpkg -l "php${version}-*" 2>/dev/null | grep "^ii" | awk '{print "  * " $2}'
            ;;
        dnf|yum)
            local v_nodot="${version//./}"
            $pm list installed "php${v_nodot}*" 2>/dev/null | grep -v "^Installed" | awk '{print "  * " $1}'
            ;;
    esac

    echo ""
}

# === info.sh ===

cmd_info() {
    local version
    version=$(get_current_version)

    if [[ -z "$version" ]]; then
        error "No PHP version active"
        return 1
    fi

    local php_bin
    php_bin=$(get_php_binary "$version")
    local source
    source=$(get_version_source)

    print_header

    # PHPVM Info
    echo "${BOLD}PHPVM:${RESET}"
    echo "  Version: ${PHPVM_VERSION}"
    echo "  GitHub:  https://github.com/${PHPVM_REPO}"
    echo ""

    # PHP Version Info
    echo "${BOLD}PHP Information:${RESET}"
    echo ""

    echo "${CYAN}Version:${RESET}"
    "$php_bin" -v 2>/dev/null | head -1
    echo ""

    echo "${CYAN}Binary:${RESET} $php_bin"
    echo "${CYAN}Source:${RESET} $source"
    echo ""

    # php.ini locations
    echo "${CYAN}Configuration Files:${RESET}"
    local ini_cli
    ini_cli=$("$php_bin" --ini 2>/dev/null | grep "Loaded Configuration File" | cut -d':' -f2 | tr -d ' ')
    echo "  CLI php.ini: ${ini_cli:-Not found}"

    local fpm_ini="/etc/php/${version}/fpm/php.ini"
    if [[ -f "$fpm_ini" ]]; then
        echo "  FPM php.ini: $fpm_ini"
    fi
    echo ""

    # Key settings
    echo "${CYAN}Key Settings:${RESET}"
    echo "  memory_limit:        $("$php_bin" -r 'echo ini_get("memory_limit");' 2>/dev/null)"
    echo "  max_execution_time:  $("$php_bin" -r 'echo ini_get("max_execution_time");' 2>/dev/null)s"
    echo "  upload_max_filesize: $("$php_bin" -r 'echo ini_get("upload_max_filesize");' 2>/dev/null)"
    echo "  post_max_size:       $("$php_bin" -r 'echo ini_get("post_max_size");' 2>/dev/null)"
    echo ""

    # Composer info
    local composer_dir="$PHPVM_DIR/$version/composer"
    echo "${CYAN}Composer:${RESET}"
    if [[ -f "$composer_dir/composer.phar" ]]; then
        local composer_version
        composer_version=$("$php_bin" "$composer_dir/composer.phar" --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
        echo "  Version: $composer_version"
        echo "  Global packages: $composer_dir/vendor/"
    else
        echo "  Not installed for this PHP version"
        echo "  Run 'composer' to install"
    fi
    echo ""

    # Version Resolution Order
    echo "${CYAN}Version Resolution Order:${RESET}"
    echo ""

    local active_found=false

    # 1. Session
    if [[ -n "${PHPVERSION_USE:-}" ]]; then
        echo "  ${GREEN}[x]${RESET} 1. Session (PHPVERSION_USE=${PHPVERSION_USE})"
        active_found=true
    else
        echo "  ${DIM}[ ] 1. Session (PHPVERSION_USE not set)${RESET}"
    fi

    # 2. Local
    local local_file
    local_file=$(find_phpversion_file 2>/dev/null)
    if [[ -n "$local_file" && "$active_found" == "false" ]]; then
        local local_version
        local_version=$(cat "$local_file" 2>/dev/null | tr -d '[:space:]')
        echo "  ${GREEN}[x]${RESET} 2. Local (${local_file} = ${local_version})"
        active_found=true
    elif [[ -n "$local_file" ]]; then
        local local_version
        local_version=$(cat "$local_file" 2>/dev/null | tr -d '[:space:]')
        echo "  ${DIM}[ ] 2. Local (${local_file} = ${local_version})${RESET}"
    else
        echo "  ${DIM}[ ] 2. Local (no .phpversion found)${RESET}"
    fi

    # 3. User
    if [[ -f "$PHPVM_CONFIG" ]]; then
        local user_version
        user_version=$(cat "$PHPVM_CONFIG" 2>/dev/null | tr -d '[:space:]')
        if [[ "$active_found" == "false" ]]; then
            echo "  ${GREEN}[x]${RESET} 3. User (~/.phpvm/version = ${user_version})"
            active_found=true
        else
            echo "  ${DIM}[ ] 3. User (~/.phpvm/version = ${user_version})${RESET}"
        fi
    else
        echo "  ${DIM}[ ] 3. User (~/.phpvm/version not set)${RESET}"
    fi

    # 4. System
    if [[ -f "$SYSTEM_CONFIG" ]]; then
        local system_version
        system_version=$(cat "$SYSTEM_CONFIG" 2>/dev/null | tr -d '[:space:]')
        if [[ "$active_found" == "false" ]]; then
            echo "  ${GREEN}[x]${RESET} 4. System (/etc/phpvm/version = ${system_version})"
            active_found=true
        else
            echo "  ${DIM}[ ] 4. System (/etc/phpvm/version = ${system_version})${RESET}"
        fi
    else
        echo "  ${DIM}[ ] 4. System (/etc/phpvm/version not set)${RESET}"
    fi

    # 5. Fallback
    if [[ "$active_found" == "false" ]]; then
        echo "  ${GREEN}[x]${RESET} 5. Fallback (first installed)"
    else
        echo "  ${DIM}[ ] 5. Fallback (first installed)${RESET}"
    fi

    echo ""
}

# === config_edit.sh ===

view_config_file() {
    local file="$1"
    local title="$2"

    if [[ "$UI_MODE" == "gum" ]]; then
        gum pager --show-line-numbers < "$file"
    else
        # Fallback to less or cat
        if command_exists less; then
            less -N "$file"
        else
            cat -n "$file"
        fi
    fi
}

cmd_config() {
    local version
    version=$(get_current_version)

    if [[ -z "$version" ]]; then
        error "No PHP version active"
        return 1
    fi

    local choice
    choice=$(gum_menu "Select configuration file:" \
        "CLI php.ini" \
        "FPM php.ini" \
        "FPM Pool (www.conf)")

    local file
    case "$choice" in
        "CLI php.ini")
            file="/etc/php/${version}/cli/php.ini"
            ;;
        "FPM php.ini")
            file="/etc/php/${version}/fpm/php.ini"
            ;;
        "FPM Pool"*)
            file="/etc/php/${version}/fpm/pool.d/www.conf"
            ;;
        *)
            msg "Cancelled"
            return
            ;;
    esac

    if [[ ! -f "$file" ]]; then
        error "Configuration file not found: $file"
        return 1
    fi

    # Ask what to do with the file
    local action
    action=$(gum_menu "What would you like to do with $file?" \
        "View" \
        "Edit")

    case "$action" in
        "View")
            view_config_file "$file" "$choice"
            ;;
        "Edit")
            edit_config_file "$file" "$choice" "$version"
            ;;
        *)
            msg "Cancelled"
            ;;
    esac
}

edit_config_file() {
    local file="$1"
    local choice="$2"
    local version="$3"

    # Select editor
    local editor
    if command_exists micro; then
        editor="micro"
    elif [[ -n "$EDITOR" ]]; then
        editor="$EDITOR"
    elif command_exists nano; then
        editor="nano"
    elif command_exists vim; then
        editor="vim"
    else
        editor="vi"
    fi

    info_log "Opening $file with $editor..."
    run_privileged "$editor" "$file"

    # Offer to restart FPM if editing FPM config
    if [[ "$choice" == "FPM"* ]]; then
        local service="php${version}-fpm"
        if systemctl is-active "$service" &>/dev/null; then
            if gum_confirm "Restart PHP-FPM to apply changes?"; then
                run_privileged systemctl restart "$service"
                success "PHP-FPM restarted"
            fi
        fi
    fi
}

# === fpm.sh ===

cmd_fpm() {
    local installed
    installed=($(get_installed_versions))

    if [[ ${#installed[@]} -eq 0 ]]; then
        error "No PHP versions installed"
        return 1
    fi

    # Find installed FPM services
    local fpm_services=()
    for v in "${installed[@]}"; do
        local service="php${v}-fpm"
        if systemctl list-unit-files "$service.service" &>/dev/null; then
            fpm_services+=("$v")
        fi
    done

    if [[ ${#fpm_services[@]} -eq 0 ]]; then
        warn "No PHP-FPM services installed"
        if gum_confirm "Would you like to install PHP-FPM?"; then
            local version
            version=$(get_current_version)
            local pm=$(get_package_manager)
            case "$pm" in
                apt) run_privileged apt-get install -y "php${version}-fpm" ;;
                dnf|yum) run_privileged $pm install -y "php${version//./}-php-fpm" ;;
            esac
            success "PHP-FPM installed"
        fi
        return
    fi

    # Main FPM menu
    local action
    action=$(gum_menu "PHP-FPM Management:" \
        "Service Control (start/stop/restart)" \
        "Enable/Disable Service" \
        "Edit Configuration" \
        "Create New Pool" \
        "Manage Pools" \
        "View Status")

    case "$action" in
        "Service Control"*)
            fpm_service_control "${fpm_services[@]}"
            ;;
        "Enable/Disable"*)
            fpm_enable_disable "${fpm_services[@]}"
            ;;
        "Edit Configuration")
            cmd_config
            ;;
        "Create New Pool")
            fpm_create_pool
            ;;
        "Manage Pools")
            fpm_manage_pools
            ;;
        "View Status")
            fpm_view_status "${fpm_services[@]}"
            ;;
        *)
            msg "Cancelled"
            ;;
    esac
}

fpm_service_control() {
    local services=("$@")
    local current
    current=$(get_current_version)

    # Build service options with status (no colors in menu labels)
    local options=()
    for v in "${services[@]}"; do
        local service="php${v}-fpm"
        local status
        if systemctl is-active "$service" &>/dev/null; then
            status="running"
        else
            status="stopped"
        fi
        local label="PHP $v FPM [$status]"
        [[ "$v" == "$current" ]] && label="$label <- current"
        options+=("$label")
    done

    local choice
    choice=$(gum_menu "Select FPM service:" "${options[@]}")

    if [[ -z "$choice" ]]; then
        return
    fi

    local version
    version=$(echo "$choice" | grep -oE '[0-9]+\.[0-9]+')
    local service="php${version}-fpm"

    local action
    action=$(gum_menu "Action for $service:" \
        "Start" \
        "Stop" \
        "Restart" \
        "Reload" \
        "Status")

    case "$action" in
        "Start")
            if gum_confirm "Start $service?"; then
                run_privileged systemctl start "$service" && success "Started $service"
            fi
            ;;
        "Stop")
            if gum_confirm "Stop $service?" "no"; then
                run_privileged systemctl stop "$service" && success "Stopped $service"
            fi
            ;;
        "Restart")
            if gum_confirm "Restart $service?"; then
                run_privileged systemctl restart "$service" && success "Restarted $service"
            fi
            ;;
        "Reload")
            if gum_confirm "Reload $service?"; then
                run_privileged systemctl reload "$service" && success "Reloaded $service"
            fi
            ;;
        "Status")
            systemctl status "$service"
            ;;
    esac
}

fpm_enable_disable() {
    local services=("$@")

    # Build options (no colors in menu labels)
    local options=()
    for v in "${services[@]}"; do
        local service="php${v}-fpm"
        local status
        if systemctl is-enabled "$service" &>/dev/null; then
            status="enabled"
        else
            status="disabled"
        fi
        options+=("PHP $v FPM [$status]")
    done

    local choice
    choice=$(gum_menu "Select FPM service:" "${options[@]}")

    if [[ -z "$choice" ]]; then
        return
    fi

    local version
    version=$(echo "$choice" | grep -oE '[0-9]+\.[0-9]+')
    local service="php${version}-fpm"

    if systemctl is-enabled "$service" &>/dev/null; then
        if gum_confirm "Disable $service?"; then
            run_privileged systemctl disable "$service"
            success "$service disabled"
        fi
    else
        if gum_confirm "Enable $service?"; then
            run_privileged systemctl enable "$service"
            success "$service enabled"
        fi
    fi
}

fpm_create_pool() {
    local version
    version=$(get_current_version)

    echo ""
    echo "${BOLD}Create New PHP-FPM Pool${RESET}"
    echo ""

    local name
    name=$(gum_input "Pool name:" "" "myapp")

    if [[ -z "$name" ]]; then
        msg "Cancelled"
        return
    fi

    local user
    user=$(gum_input "User:" "$(whoami)")

    local group
    group=$(gum_input "Group:" "$(id -gn)")

    local socket
    socket=$(gum_input "Socket path:" "/run/php/${name}.sock")

    local pool_file="/etc/php/${version}/fpm/pool.d/${name}.conf"

    if [[ -f "$pool_file" ]]; then
        error "Pool configuration already exists: $pool_file"
        return 1
    fi

    run_privileged tee "$pool_file" > /dev/null <<EOF
[$name]
user = $user
group = $group
listen = $socket
listen.owner = www-data
listen.group = www-data
listen.mode = 0660

pm = dynamic
pm.max_children = 5
pm.start_servers = 2
pm.min_spare_servers = 1
pm.max_spare_servers = 3

; Logging
catch_workers_output = yes
php_admin_flag[log_errors] = on
EOF

    success "Pool created: $pool_file"

    if gum_confirm "Restart PHP-FPM to activate?"; then
        run_privileged systemctl restart "php${version}-fpm"
        success "PHP-FPM restarted"
    fi
}

fpm_manage_pools() {
    local version
    version=$(get_current_version)
    local pool_dir="/etc/php/${version}/fpm/pool.d"

    if [[ ! -d "$pool_dir" ]]; then
        error "Pool directory not found: $pool_dir"
        return 1
    fi

    local pools=()
    while IFS= read -r -d '' file; do
        local name
        name=$(basename "$file")
        if [[ "$name" == *.disabled ]]; then
            pools+=("${name%.conf.disabled} (disabled)")
        else
            pools+=("${name%.conf} (enabled)")
        fi
    done < <(find "$pool_dir" -name "*.conf*" -print0 2>/dev/null)

    if [[ ${#pools[@]} -eq 0 ]]; then
        warn "No pools found"
        return
    fi

    local choice
    choice=$(gum_menu "Select pool:" "${pools[@]}")

    if [[ -z "$choice" ]]; then
        return
    fi

    local pool_name
    pool_name=$(echo "$choice" | cut -d' ' -f1)

    local action
    action=$(gum_menu "Action for $pool_name:" \
        "Edit" \
        "Enable/Disable" \
        "Delete")

    case "$action" in
        "Edit")
            local file="$pool_dir/${pool_name}.conf"
            [[ ! -f "$file" ]] && file="$pool_dir/${pool_name}.conf.disabled"
            run_privileged "${EDITOR:-nano}" "$file"
            ;;
        "Enable/Disable")
            if [[ -f "$pool_dir/${pool_name}.conf" ]]; then
                run_privileged mv "$pool_dir/${pool_name}.conf" "$pool_dir/${pool_name}.conf.disabled"
                success "Pool $pool_name disabled"
            else
                run_privileged mv "$pool_dir/${pool_name}.conf.disabled" "$pool_dir/${pool_name}.conf"
                success "Pool $pool_name enabled"
            fi
            ;;
        "Delete")
            if gum_confirm "Delete pool $pool_name?" "no"; then
                run_privileged rm -f "$pool_dir/${pool_name}.conf" "$pool_dir/${pool_name}.conf.disabled"
                success "Pool $pool_name deleted"
            fi
            ;;
    esac
}

fpm_view_status() {
    local services=("$@")

    echo ""
    echo "${BOLD}PHP-FPM Services Status:${RESET}"
    echo ""

    for v in "${services[@]}"; do
        local service="php${v}-fpm"
        local active_status enabled_status

        if systemctl is-active "$service" &>/dev/null; then
            active_status="${GREEN}running${RESET}"
        else
            active_status="${RED}stopped${RESET}"
        fi

        if systemctl is-enabled "$service" &>/dev/null; then
            enabled_status="${GREEN}enabled${RESET}"
        else
            enabled_status="${YELLOW}disabled${RESET}"
        fi

        printf "  PHP %s FPM: %s / %s\n" "$v" "$active_status" "$enabled_status"
    done

    echo ""
}

# === worker.sh ===

SUPERVISOR_CONF_DIR="/etc/supervisor/conf.d"
PHPVM_WORKER_PREFIX="phpvm_worker_"


supervisor_is_installed() {
    command_exists supervisorctl
}

supervisor_get_version() {
    supervisorctl version 2>/dev/null || supervisord --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+(\.[0-9]+)?'
}

supervisor_install() {
    local pm=$(get_package_manager)

    if supervisor_is_installed; then
        local version
        version=$(supervisor_get_version)
        warn "Supervisor is already installed (v${version})"

        if ! gum_confirm "Reinstall/upgrade supervisor?"; then
            return 0
        fi
    fi

    info_log "Installing supervisor..."

    case "$pm" in
        apt)
            run_privileged apt-get update -qq 2>/dev/null
            # Suppress tmpfiles warnings in containers
            run_privileged apt-get install -y supervisor 2>&1 | grep -v "tmpfiles.d" || true
            ;;
        dnf)
            run_privileged dnf install -y supervisor 2>&1 | grep -v "tmpfiles.d" || true
            ;;
        yum)
            run_privileged yum install -y supervisor 2>&1 | grep -v "tmpfiles.d" || true
            ;;
        *)
            error "Unsupported package manager: $pm"
            echo ""
            echo "Please install supervisor manually:"
            echo "  pip install supervisor"
            return 1
            ;;
    esac

    if supervisor_is_installed; then
        local version
        version=$(supervisor_get_version)
        success "Supervisor installed (v${version})"

        # Enable and start supervisor
        if gum_confirm "Start supervisor now?"; then
            run_privileged systemctl enable supervisor 2>/dev/null || \
            run_privileged systemctl enable supervisord 2>/dev/null || true
            run_privileged systemctl start supervisor 2>/dev/null || \
            run_privileged systemctl start supervisord 2>/dev/null || true
            success "Supervisor started"
        fi
        return 0
    else
        error "Supervisor installation failed"
        return 1
    fi
}

supervisor_uninstall() {
    if ! supervisor_is_installed; then
        warn "Supervisor is not installed"
        return 0
    fi

    if ! gum_confirm "Uninstall supervisor?" "no"; then
        return 0
    fi

    local pm=$(get_package_manager)

    # Stop service first
    run_privileged systemctl stop supervisor 2>/dev/null || \
    run_privileged systemctl stop supervisord 2>/dev/null || true
    run_privileged systemctl disable supervisor 2>/dev/null || \
    run_privileged systemctl disable supervisord 2>/dev/null || true

    case "$pm" in
        apt)
            if gum_confirm "Remove configuration files too?" "no"; then
                run_privileged apt-get purge -y supervisor
            else
                run_privileged apt-get remove -y supervisor
            fi
            run_privileged apt-get autoremove -y
            ;;
        dnf|yum)
            run_privileged $pm remove -y supervisor
            ;;
    esac

    success "Supervisor uninstalled"
}

supervisor_service() {
    local action="$1"

    if ! supervisor_is_installed; then
        error "Supervisor is not installed"
        return 1
    fi

    # Try both service names (supervisor on Debian, supervisord on RHEL)
    case "$action" in
        start)
            run_privileged systemctl start supervisor 2>/dev/null || \
            run_privileged systemctl start supervisord 2>/dev/null && \
            success "Supervisor started"
            ;;
        stop)
            run_privileged systemctl stop supervisor 2>/dev/null || \
            run_privileged systemctl stop supervisord 2>/dev/null && \
            success "Supervisor stopped"
            ;;
        restart)
            run_privileged systemctl restart supervisor 2>/dev/null || \
            run_privileged systemctl restart supervisord 2>/dev/null && \
            success "Supervisor restarted"
            ;;
        status)
            systemctl status supervisor 2>/dev/null || \
            systemctl status supervisord 2>/dev/null
            ;;
        enable)
            run_privileged systemctl enable supervisor 2>/dev/null || \
            run_privileged systemctl enable supervisord 2>/dev/null && \
            success "Supervisor enabled"
            ;;
        disable)
            run_privileged systemctl disable supervisor 2>/dev/null || \
            run_privileged systemctl disable supervisord 2>/dev/null && \
            success "Supervisor disabled"
            ;;
        *)
            error "Unknown action: $action"
            return 1
            ;;
    esac
}

supervisor_ensure_installed() {
    if ! supervisor_is_installed; then
        warn "Supervisor is not installed"
        if gum_confirm "Install supervisor?"; then
            supervisor_install || return 1
        else
            return 1
        fi
    fi
    return 0
}

check_supervisor() {
    supervisor_ensure_installed
}

get_worker_config_path() {
    local project_id="$1"
    local worker_name="$2"
    echo "${SUPERVISOR_CONF_DIR}/${PHPVM_WORKER_PREFIX}${project_id}_${worker_name}.conf"
}

list_project_workers() {
    local project_id
    project_id=$(get_project_id)

    local workers=()
    if [[ -d "$SUPERVISOR_CONF_DIR" ]]; then
        while IFS= read -r -d '' file; do
            local name
            name=$(basename "$file" .conf | sed "s/${PHPVM_WORKER_PREFIX}${project_id}_//")
            workers+=("$name")
        done < <(find "$SUPERVISOR_CONF_DIR" -name "${PHPVM_WORKER_PREFIX}${project_id}_*.conf" -print0 2>/dev/null)
    fi

    printf '%s\n' "${workers[@]}"
}

get_worker_status() {
    local program_name="$1"
    supervisorctl status "$program_name" 2>/dev/null | awk '{print $2}'
}

cmd_worker() {
    local framework
    framework=$(detect_framework)

    if [[ -z "$framework" ]]; then
        error "Not in a PHP framework project directory"
        echo "Supported: Laravel, Symfony, Yii2"
        return 1
    fi

    check_supervisor || return 1

    local action
    action=$(gum_menu "Queue Worker Management ($(get_framework_display_name)):" \
        "Add Worker" \
        "List Workers" \
        "Start Worker" \
        "Stop Worker" \
        "Restart Worker" \
        "Remove Worker" \
        "View Logs")

    case "$action" in
        "Add Worker")     worker_add ;;
        "List Workers")   worker_list ;;
        "Start Worker")   worker_control "start" ;;
        "Stop Worker")    worker_control "stop" ;;
        "Restart Worker") worker_control "restart" ;;
        "Remove Worker")  worker_remove ;;
        "View Logs")      worker_logs ;;
        *)                msg "Cancelled" ;;
    esac
}

worker_add() {
    local framework
    framework=$(detect_framework)
    local project_id
    project_id=$(get_project_id)
    local project_name
    project_name=$(get_project_name)
    local php_bin
    php_bin=$(get_php_binary)

    echo ""
    echo "${BOLD}Add Queue Worker${RESET}"
    echo ""

    # Worker name
    local worker_name
    worker_name=$(gum_input "Worker name:" "" "default")
    [[ -z "$worker_name" ]] && { msg "Cancelled"; return; }

    # Sanitize worker name
    worker_name=$(echo "$worker_name" | tr -cd 'a-zA-Z0-9_-')

    local command=""
    local num_procs=1

    # Framework-specific options
    case "$framework" in
        laravel)
            if has_horizon; then
                local use_horizon
                use_horizon=$(gum_menu "Laravel Horizon is installed. Use:" \
                    "Horizon (recommended for production)" \
                    "queue:work (standard)")

                if [[ "$use_horizon" == "Horizon"* ]]; then
                    command="$php_bin $PWD/artisan horizon"
                    num_procs=1  # Horizon manages its own workers
                else
                    local queue
                    queue=$(gum_input "Queue name:" "default")
                    local connection
                    connection=$(gum_input "Connection:" "redis")
                    command="$php_bin $PWD/artisan queue:work $connection --queue=$queue --sleep=3 --tries=3"
                fi
            else
                local queue
                queue=$(gum_input "Queue name:" "default")
                local connection
                connection=$(gum_input "Connection:" "database")
                command="$php_bin $PWD/artisan queue:work $connection --queue=$queue --sleep=3 --tries=3"
            fi
            ;;
        symfony)
            local transport
            transport=$(gum_input "Transport name:" "async")
            command="$php_bin $PWD/bin/console messenger:consume $transport --time-limit=3600"
            ;;
        yii)
            command="$php_bin $PWD/yii queue/listen --verbose"
            ;;
    esac

    # Number of processes
    local procs_input
    procs_input=$(gum_input "Number of processes:" "$num_procs")
    num_procs="${procs_input:-$num_procs}"

    # User
    local user
    user=$(gum_input "Run as user:" "$(whoami)")

    # Generate config
    local config_path
    config_path=$(get_worker_config_path "$project_id" "$worker_name")
    local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${worker_name}"

    local config_content="[program:${program_name}]
process_name=%(program_name)s_%(process_num)02d
command=${command}
directory=${PWD}
user=${user}
numprocs=${num_procs}
autostart=true
autorestart=true
startsecs=1
startretries=3
redirect_stderr=true
stdout_logfile=/var/log/supervisor/${program_name}.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=5
stopwaitsecs=60
; Project: ${project_name}
; Path: ${PWD}
; Framework: ${framework}
"

    echo ""
    echo "${CYAN}Supervisor configuration:${RESET}"
    echo "$config_content"
    echo ""

    if ! gum_confirm "Create this worker?"; then
        msg "Cancelled"
        return
    fi

    # Write config
    echo "$config_content" | run_privileged tee "$config_path" > /dev/null

    # Reload supervisor
    run_privileged supervisorctl reread
    run_privileged supervisorctl update

    success "Worker '$worker_name' created"
    info_log "Config: $config_path"

    if gum_confirm "Start worker now?"; then
        run_privileged supervisorctl start "${program_name}:*"
        success "Worker started"
    fi
}

worker_list() {
    local project_id
    project_id=$(get_project_id)

    echo ""
    echo "${BOLD}Queue Workers for $(get_project_name):${RESET}"
    echo ""

    local workers
    workers=$(list_project_workers)

    if [[ -z "$workers" ]]; then
        warn "No workers configured for this project"
        return
    fi

    while IFS= read -r worker; do
        local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${worker}"
        local status
        status=$(get_worker_status "$program_name:*")

        local status_color
        case "$status" in
            RUNNING) status_color="${GREEN}${status}${RESET}" ;;
            STOPPED) status_color="${YELLOW}${status}${RESET}" ;;
            *)       status_color="${RED}${status}${RESET}" ;;
        esac

        printf "  %-20s %s\n" "$worker" "$status_color"
    done <<< "$workers"

    echo ""
}

worker_control() {
    local action="$1"
    local project_id
    project_id=$(get_project_id)

    local workers
    workers=$(list_project_workers)

    if [[ -z "$workers" ]]; then
        warn "No workers configured for this project"
        return
    fi

    # Build options with status
    local options=()
    while IFS= read -r worker; do
        local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${worker}"
        local status
        status=$(get_worker_status "$program_name:*")
        options+=("$worker [$status]")
    done <<< "$workers"

    options+=("All workers")

    local choice
    choice=$(gum_menu "Select worker to ${action}:" "${options[@]}")

    [[ -z "$choice" ]] && { msg "Cancelled"; return; }

    # Confirm dangerous actions
    local confirm_default="yes"
    [[ "$action" == "stop" ]] && confirm_default="no"

    if [[ "$choice" == "All workers" ]]; then
        if ! gum_confirm "${action^} all workers?" "$confirm_default"; then
            msg "Cancelled"
            return
        fi
        while IFS= read -r worker; do
            local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${worker}"
            run_privileged supervisorctl "$action" "${program_name}:*"
        done <<< "$workers"
        success "All workers ${action}ed"
    else
        local worker_name
        worker_name=$(echo "$choice" | cut -d' ' -f1)
        if ! gum_confirm "${action^} worker '$worker_name'?" "$confirm_default"; then
            msg "Cancelled"
            return
        fi
        local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${worker_name}"
        run_privileged supervisorctl "$action" "${program_name}:*"
        success "Worker '$worker_name' ${action}ed"
    fi
}

worker_remove() {
    local project_id
    project_id=$(get_project_id)

    local workers
    workers=$(list_project_workers)

    if [[ -z "$workers" ]]; then
        warn "No workers configured for this project"
        return
    fi

    local options=()
    while IFS= read -r worker; do
        options+=("$worker")
    done <<< "$workers"

    local choice
    choice=$(gum_menu "Select worker to remove:" "${options[@]}")

    [[ -z "$choice" ]] && { msg "Cancelled"; return; }

    if ! gum_confirm "Remove worker '$choice'?" "no"; then
        msg "Cancelled"
        return
    fi

    local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${choice}"
    local config_path
    config_path=$(get_worker_config_path "$project_id" "$choice")

    # Stop worker first
    run_privileged supervisorctl stop "${program_name}:*" 2>/dev/null

    # Remove config
    run_privileged rm -f "$config_path"

    # Update supervisor
    run_privileged supervisorctl reread
    run_privileged supervisorctl update

    success "Worker '$choice' removed"
}

worker_logs() {
    local project_id
    project_id=$(get_project_id)

    local workers
    workers=$(list_project_workers)

    if [[ -z "$workers" ]]; then
        warn "No workers configured for this project"
        return
    fi

    local options=()
    while IFS= read -r worker; do
        options+=("$worker")
    done <<< "$workers"

    local choice
    choice=$(gum_menu "Select worker to view logs:" "${options[@]}")

    [[ -z "$choice" ]] && { msg "Cancelled"; return; }

    local program_name="${PHPVM_WORKER_PREFIX}${project_id}_${choice}"
    local log_file="/var/log/supervisor/${program_name}.log"

    if [[ ! -f "$log_file" ]]; then
        warn "Log file not found: $log_file"
        return
    fi

    local action
    action=$(gum_menu "Log action:" \
        "View last 100 lines" \
        "Follow logs (tail -f)" \
        "View full log")

    case "$action" in
        "View last"*)
            run_privileged tail -n 100 "$log_file" | gum pager
            ;;
        "Follow"*)
            info_log "Press Ctrl+C to stop"
            run_privileged tail -f "$log_file"
            ;;
        "View full"*)
            run_privileged cat "$log_file" | gum pager
            ;;
    esac
}

# === cron.sh ===

PHPVM_CRON_MARKER="# PHPVM:"

get_cron_marker() {
    local project_id
    project_id=$(get_project_id)
    echo "${PHPVM_CRON_MARKER}${project_id}"
}

list_project_crons() {
    local marker
    marker=$(get_cron_marker)

    crontab -l 2>/dev/null | grep -A1 "$marker" | grep -v "^--$" | grep -v "^${PHPVM_CRON_MARKER}"
}

count_project_crons() {
    local marker
    marker=$(get_cron_marker)

    crontab -l 2>/dev/null | grep "$marker" | wc -l
}

cmd_cron() {
    local framework
    framework=$(detect_framework)

    if [[ -z "$framework" ]]; then
        error "Not in a PHP framework project directory"
        echo "Supported: Laravel, Symfony, Yii2"
        return 1
    fi

    local action
    action=$(gum_menu "Scheduler/Cron Management ($(get_framework_display_name)):" \
        "Add Scheduler" \
        "Add Custom Cron" \
        "List Crons" \
        "Remove Cron" \
        "Remove All Project Crons")

    case "$action" in
        "Add Scheduler")       cron_add_scheduler ;;
        "Add Custom Cron")     cron_add_custom ;;
        "List Crons")          cron_list ;;
        "Remove Cron")         cron_remove ;;
        "Remove All"*)         cron_remove_all ;;
        *)                     msg "Cancelled" ;;
    esac
}

cron_add_scheduler() {
    local framework
    framework=$(detect_framework)
    local project_name
    project_name=$(get_project_name)
    local marker
    marker=$(get_cron_marker)
    local php_bin
    php_bin=$(get_php_binary)

    echo ""
    echo "${BOLD}Add Scheduler Cron${RESET}"
    echo ""

    local schedule="* * * * *"
    local command=""
    local description=""

    case "$framework" in
        laravel)
            command="cd $PWD && $php_bin artisan schedule:run >> /dev/null 2>&1"
            description="Laravel scheduler"
            ;;
        symfony)
            # Symfony doesn't have built-in scheduler like Laravel
            local schedule_cmd
            schedule_cmd=$(gum_input "Symfony command to schedule:" "app:my-command")
            command="cd $PWD && $php_bin bin/console $schedule_cmd >> /dev/null 2>&1"
            description="Symfony: $schedule_cmd"

            # Ask for custom schedule
            local custom_schedule
            custom_schedule=$(gum_input "Cron schedule:" "$schedule")
            schedule="${custom_schedule:-$schedule}"
            ;;
        yii)
            command="cd $PWD && $php_bin yii schedule/run >> /dev/null 2>&1"
            description="Yii2 scheduler"
            ;;
    esac

    echo ""
    echo "${CYAN}Cron entry:${RESET}"
    echo "$schedule $command"
    echo ""

    if ! gum_confirm "Add this cron job?"; then
        msg "Cancelled"
        return
    fi

    # Add to crontab
    local new_cron="${marker} ${project_name} - ${description}
${schedule} ${command}"

    (crontab -l 2>/dev/null; echo "$new_cron") | crontab -

    success "Scheduler cron added"
    info_log "Project: $project_name"
}

cron_add_custom() {
    local framework
    framework=$(detect_framework)
    local project_name
    project_name=$(get_project_name)
    local marker
    marker=$(get_cron_marker)
    local php_bin
    php_bin=$(get_php_binary)

    echo ""
    echo "${BOLD}Add Custom Cron${RESET}"
    echo ""

    # Schedule selection
    local schedule
    local schedule_choice
    schedule_choice=$(gum_menu "Select schedule:" \
        "Every minute (* * * * *)" \
        "Every 5 minutes (*/5 * * * *)" \
        "Every hour (0 * * * *)" \
        "Every day at midnight (0 0 * * *)" \
        "Every Monday at 9am (0 9 * * 1)" \
        "Custom schedule")

    case "$schedule_choice" in
        "Every minute"*)     schedule="* * * * *" ;;
        "Every 5"*)          schedule="*/5 * * * *" ;;
        "Every hour"*)       schedule="0 * * * *" ;;
        "Every day"*)        schedule="0 0 * * *" ;;
        "Every Monday"*)     schedule="0 9 * * 1" ;;
        "Custom"*)
            schedule=$(gum_input "Cron schedule (min hour day month weekday):" "* * * * *")
            ;;
        *)
            msg "Cancelled"
            return
            ;;
    esac

    # Command selection
    local command=""
    local description=""

    case "$framework" in
        laravel)
            local artisan_cmd
            artisan_cmd=$(gum_input "Artisan command:" "inspire")
            command="cd $PWD && $php_bin artisan $artisan_cmd >> /dev/null 2>&1"
            description="artisan $artisan_cmd"
            ;;
        symfony)
            local console_cmd
            console_cmd=$(gum_input "Console command:" "app:my-command")
            command="cd $PWD && $php_bin bin/console $console_cmd >> /dev/null 2>&1"
            description="console $console_cmd"
            ;;
        yii)
            local yii_cmd
            yii_cmd=$(gum_input "Yii command:" "my/command")
            command="cd $PWD && $php_bin yii $yii_cmd >> /dev/null 2>&1"
            description="yii $yii_cmd"
            ;;
    esac

    echo ""
    echo "${CYAN}Cron entry:${RESET}"
    echo "$schedule $command"
    echo ""

    if ! gum_confirm "Add this cron job?"; then
        msg "Cancelled"
        return
    fi

    # Add to crontab
    local new_cron="${marker} ${project_name} - ${description}
${schedule} ${command}"

    (crontab -l 2>/dev/null; echo "$new_cron") | crontab -

    success "Custom cron added"
}

cron_list() {
    local marker
    marker=$(get_cron_marker)
    local project_name
    project_name=$(get_project_name)

    echo ""
    echo "${BOLD}Cron Jobs for ${project_name}:${RESET}"
    echo ""

    local crons
    crons=$(crontab -l 2>/dev/null | grep -A1 "$marker")

    if [[ -z "$crons" ]]; then
        warn "No cron jobs configured for this project"
        return
    fi

    local count=1
    while IFS= read -r line; do
        if [[ "$line" == "${PHPVM_CRON_MARKER}"* ]]; then
            local desc
            desc=$(echo "$line" | sed "s/${PHPVM_CRON_MARKER}[^ ]* //")
            echo "${CYAN}[$count] $desc${RESET}"
        elif [[ -n "$line" && "$line" != "--" ]]; then
            echo "    $line"
            echo ""
            ((count++))
        fi
    done <<< "$crons"
}

cron_remove() {
    local marker
    marker=$(get_cron_marker)

    local crons
    crons=$(crontab -l 2>/dev/null | grep "$marker")

    if [[ -z "$crons" ]]; then
        warn "No cron jobs configured for this project"
        return
    fi

    # Build options
    local options=()
    while IFS= read -r line; do
        local desc
        desc=$(echo "$line" | sed "s/${PHPVM_CRON_MARKER}[^ ]* //")
        options+=("$desc")
    done <<< "$crons"

    local choice
    choice=$(gum_menu "Select cron to remove:" "${options[@]}")

    [[ -z "$choice" ]] && { msg "Cancelled"; return; }

    if ! gum_confirm "Remove this cron job?" "no"; then
        msg "Cancelled"
        return
    fi

    # Remove from crontab (remove marker line and following command line)
    local escaped_choice
    escaped_choice=$(echo "$choice" | sed 's/[[\.*^$()+?{|]/\\&/g')

    crontab -l 2>/dev/null | grep -v "${marker}.*${escaped_choice}" | \
        awk -v marker="$marker" -v choice="$choice" '
            BEGIN { skip_next = 0 }
            {
                if (skip_next) { skip_next = 0; next }
                if ($0 ~ marker && $0 ~ choice) { skip_next = 1; next }
                print
            }
        ' | crontab -

    success "Cron job removed"
}

cron_remove_all() {
    local marker
    marker=$(get_cron_marker)
    local project_name
    project_name=$(get_project_name)

    local count
    count=$(count_project_crons)

    if [[ "$count" -eq 0 ]]; then
        warn "No cron jobs configured for this project"
        return
    fi

    echo ""
    warn "This will remove $count cron job(s) for '$project_name'"
    echo ""

    if ! gum_confirm "Remove all project crons?" "no"; then
        msg "Cancelled"
        return
    fi

    # Remove all project crons from crontab
    crontab -l 2>/dev/null | awk -v marker="$marker" '
        BEGIN { skip_next = 0 }
        {
            if (skip_next) { skip_next = 0; next }
            if ($0 ~ marker) { skip_next = 1; next }
            print
        }
    ' | crontab -

    success "All project crons removed"
}

# === serve.sh ===

cmd_serve() {
    local php_bin
    php_bin=$(get_php_binary)

    local framework
    framework=$(detect_framework)

    # Check for --octane flag (Laravel only)
    local use_octane=false
    local remaining_args=()

    for arg in "$@"; do
        if [[ "$arg" == "--octane" ]]; then
            use_octane=true
        else
            remaining_args+=("$arg")
        fi
    done

    set -- "${remaining_args[@]}"

    # Parse shorthand arguments
    local args=()
    local host=""
    local port=""

    if [[ $# -gt 0 ]]; then
        local first_arg="$1"

        # Check if first arg is shorthand format
        if [[ "$first_arg" =~ ^:([0-9]+)$ ]]; then
            # :8080 format -> host=0.0.0.0, port=8080
            host="0.0.0.0"
            port="${BASH_REMATCH[1]}"
            shift
        elif [[ "$first_arg" =~ ^([0-9]+)$ ]]; then
            # 8080 format -> host=127.0.0.1, port=8080
            host="127.0.0.1"
            port="${BASH_REMATCH[1]}"
            shift
        elif [[ "$first_arg" =~ ^([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+):([0-9]+)$ ]]; then
            # 10.0.0.1:8080 format
            host="${BASH_REMATCH[1]}"
            port="${BASH_REMATCH[2]}"
            shift
        elif [[ "$first_arg" =~ ^([a-zA-Z0-9.-]+):([0-9]+)$ ]]; then
            # hostname:8080 format (e.g., localhost:8080)
            host="${BASH_REMATCH[1]}"
            port="${BASH_REMATCH[2]}"
            shift
        fi
    fi

    # Handle Laravel Octane
    if [[ "$use_octane" == "true" ]]; then
        if [[ "$framework" != "laravel" ]]; then
            error "Octane is only available for Laravel projects"
            return 1
        fi
        serve_octane "$php_bin" "$host" "$port" "$@"
        return
    fi

    # Build framework-specific arguments
    if [[ -n "$host" && -n "$port" ]]; then
        case "$framework" in
            laravel)
                args=("--host=$host" "--port=$port")
                ;;
            symfony)
                args=("$host:$port")
                ;;
            yii)
                args=("$host:$port")
                ;;
            *)
                # Non-framework: handled in serve_builtin
                args=("--host" "$host" "--port" "$port")
                ;;
        esac
    fi

    # Add remaining arguments
    args+=("$@")

    case "$framework" in
        laravel)
            serve_laravel "$php_bin" "${args[@]}"
            ;;
        symfony)
            serve_symfony "$php_bin" "${args[@]}"
            ;;
        yii)
            serve_yii "$php_bin" "${args[@]}"
            ;;
        *)
            serve_builtin "$php_bin" "${args[@]}"
            ;;
    esac
}

serve_laravel() {
    local php_bin="$1"
    shift

    echo ""
    info_log "Starting Laravel development server..."
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    "$php_bin" artisan serve "$@"
}

serve_octane() {
    local php_bin="$1"
    local host="$2"
    local port="$3"
    shift 3

    # Check if Octane is installed
    if ! grep -q '"laravel/octane"' composer.json 2>/dev/null; then
        error "Laravel Octane is not installed"
        echo "Install with: composer require laravel/octane"
        return 1
    fi

    # Build octane arguments
    local octane_args=()
    [[ -n "$host" ]] && octane_args+=("--host=$host")
    [[ -n "$port" ]] && octane_args+=("--port=$port")
    octane_args+=("$@")

    echo ""
    info_log "Starting Laravel Octane..."
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    "$php_bin" artisan octane:start "${octane_args[@]}"
}

serve_symfony() {
    local php_bin="$1"
    shift

    echo ""
    info_log "Starting Symfony development server..."
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    "$php_bin" bin/console server:start "$@"
}

serve_yii() {
    local php_bin="$1"
    shift

    echo ""
    info_log "Starting Yii2 development server..."
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    "$php_bin" yii serve "$@"
}

serve_builtin() {
    local php_bin="$1"
    shift

    local host="0.0.0.0"
    local port="8000"
    local docroot="."

    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --host|-h)
                host="$2"
                shift 2
                ;;
            --port|-p)
                port="$2"
                shift 2
                ;;
            --dir|-d|-t)
                docroot="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Auto-detect document root
    if [[ "$docroot" == "." ]]; then
        if [[ -d "public" ]]; then
            docroot="public"
        elif [[ -d "web" ]]; then
            docroot="web"
        elif [[ -d "www" ]]; then
            docroot="www"
        fi
    fi

    echo ""
    info_log "Starting PHP built-in server..."
    echo "${CYAN}http://${host}:${port}${RESET}"
    echo "Document root: $PWD/$docroot"
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    "$php_bin" -S "${host}:${port}" -t "$docroot"
}

# === menu.sh ===

declare -A MENU_ITEMS
declare -A MENU_HOTKEYS

init_menu_items() {
    local framework="$1"

    # Clear arrays
    MENU_ITEMS=()
    MENU_HOTKEYS=()

    # Version Management
    MENU_ITEMS["[u] Switch PHP version"]="cmd_use"
    MENU_HOTKEYS["u"]="cmd_use"

    MENU_ITEMS["[i] Install PHP/extension"]="cmd_install"
    MENU_HOTKEYS["i"]="cmd_install"

    MENU_ITEMS["[l] List installed versions"]="cmd_list"
    MENU_HOTKEYS["l"]="cmd_list"

    # Configuration
    MENU_ITEMS["[c] Edit PHP configuration"]="cmd_config"
    MENU_HOTKEYS["c"]="cmd_config"

    MENU_ITEMS["[f] Manage PHP-FPM"]="cmd_fpm"
    MENU_HOTKEYS["f"]="cmd_fpm"

    MENU_ITEMS["[n] Nginx management"]="cmd_nginx"
    MENU_HOTKEYS["n"]="cmd_nginx"

    # Development
    MENU_ITEMS["[s] Start dev server"]="cmd_serve"
    MENU_HOTKEYS["s"]="cmd_serve"

    # Logs
    MENU_ITEMS["[g] Log viewer"]="cmd_logs"
    MENU_HOTKEYS["g"]="cmd_logs"

    # Info & Help
    MENU_ITEMS["[o] Show PHP info"]="cmd_info"
    MENU_HOTKEYS["o"]="cmd_info"

    MENU_ITEMS["[?] Help"]="show_help"
    MENU_HOTKEYS["?"]="show_help"

    # Quit
    MENU_ITEMS["[q] Quit"]="quit_menu"
    MENU_HOTKEYS["q"]="quit_menu"
}

cmd_menu() {
    if [[ "$UI_MODE" != "gum" ]]; then
        fallback_menu
        return
    fi

    local framework
    framework=$(detect_framework 2>/dev/null)

    init_menu_items "$framework"

    while true; do
        clear

        # Print header
        print_menu_header "$framework"

        # Show menu with gum choose (supports arrow keys)
        local selected
        selected=$(show_interactive_menu "$framework")

        # Handle selection or check for quit
        if [[ -z "$selected" || "$selected" == "[q] Quit" ]]; then
            clear
            break
        fi

        # Execute selected command
        execute_menu_item "$selected"
    done
}

print_menu_header() {
    local framework="$1"

    local version
    version=$(get_current_version 2>/dev/null)
    local full_version
    full_version=$(get_full_php_version "$version" 2>/dev/null)

    # Build status line
    local status_line="PHP ${full_version:-$version:-not installed}"

    # Add framework info
    if [[ -n "$framework" ]]; then
        local fw_name fw_version
        fw_name=$(get_framework_display_name "$framework")
        fw_version=$(get_framework_version "$framework" 2>/dev/null)
        if [[ -n "$fw_version" ]]; then
            status_line="${status_line} | ${fw_name} v${fw_version}"
        else
            status_line="${status_line} | ${fw_name}"
        fi
    fi

    # Get service status
    local nginx_status="off"
    local fpm_status="off"

    if command -v nginx &>/dev/null && pgrep -x nginx &>/dev/null; then
        nginx_status="on"
    fi

    if [[ -n "$version" ]] && pgrep -f "php-fpm${version}\|php${version}-fpm" &>/dev/null; then
        fpm_status="on"
    fi

    # Build service status line
    local services=""
    if [[ "$nginx_status" == "on" ]]; then
        services="nginx ${GREEN}●${RESET}"
    else
        services="nginx ${RED}○${RESET}"
    fi
    if [[ "$fpm_status" == "on" ]]; then
        services="${services}  fpm ${GREEN}●${RESET}"
    else
        services="${services}  fpm ${RED}○${RESET}"
    fi

    echo ""
    gum style \
        --border double \
        --border-foreground 212 \
        --padding "0 2" \
        --margin "0 2" \
        --align center \
        "$(gum style --bold --foreground 212 "PHPVM Dashboard v${PHPVM_VERSION}")" \
        "" \
        "$status_line" \
        "" \
        "$services"
    echo ""
}

show_interactive_menu() {
    local framework="$1"

    # Menu items (only selectable items, borders handled separately)
    local items=(
        "[u] Switch PHP version"
        "[i] Install PHP/extension"
        "[l] List installed versions"
        "[c] Edit PHP configuration"
        "[f] Manage PHP-FPM"
        "[n] Nginx management"
        "[s] Start dev server"
        "[g] Log viewer"
        "[o] Show PHP info"
        "[?] Help"
        "[q] Quit"
    )

    # Group boundaries for visual display
    local group1_end=3   # Version items (0-2)
    local group2_end=6   # Configuration items (3-5)
    local group3_end=8   # Development items (6-7)
    # group4 is Other items (8-10)

    local current=0
    local total=${#items[@]}

    # Hide cursor
    tput civis 2>/dev/null || true

    # Cleanup on exit
    trap 'tput cnorm 2>/dev/null || true' RETURN

    while true; do
        # Move cursor to start of menu area
        tput cup 9 0 2>/dev/null || echo -en "\033[9;0H"

        # Print menu with groups
        echo "  ${DIM}Use ↑↓ arrows or hotkeys, Enter to select${RESET}"
        echo ""

        # Group 1: Version
        echo "  ${DIM}┌─ Version ─────────────┐${RESET}"
        for i in 0 1 2; do
            print_menu_line "$i" "$current" "${items[$i]}"
        done

        # Group 2: Configuration
        echo "  ${DIM}├─ Configuration ───────┤${RESET}"
        for i in 3 4 5; do
            print_menu_line "$i" "$current" "${items[$i]}"
        done

        # Group 3: Development
        echo "  ${DIM}├─ Development ─────────┤${RESET}"
        for i in 6 7; do
            print_menu_line "$i" "$current" "${items[$i]}"
        done

        # Group 4: Other
        echo "  ${DIM}├─ Other ───────────────┤${RESET}"
        for i in 8 9 10; do
            print_menu_line "$i" "$current" "${items[$i]}"
        done
        echo "  ${DIM}└───────────────────────┘${RESET}"

        # Read single keypress
        local key
        IFS= read -rsn1 key

        # Handle escape sequences (arrow keys)
        if [[ "$key" == $'\x1b' ]]; then
            read -rsn2 -t 0.1 key
            case "$key" in
                '[A') # Up arrow
                    ((current > 0)) && ((current--))
                    ;;
                '[B') # Down arrow
                    ((current < total - 1)) && ((current++))
                    ;;
            esac
            continue
        fi

        # Handle Enter key
        if [[ "$key" == "" ]]; then
            echo "${items[$current]}"
            return
        fi

        # Handle hotkeys
        case "$key" in
            u) echo "[u] Switch PHP version"; return ;;
            i) echo "[i] Install PHP/extension"; return ;;
            l) echo "[l] List installed versions"; return ;;
            c) echo "[c] Edit PHP configuration"; return ;;
            f) echo "[f] Manage PHP-FPM"; return ;;
            n) echo "[n] Nginx management"; return ;;
            s) echo "[s] Start dev server"; return ;;
            g) echo "[g] Log viewer"; return ;;
            o) echo "[o] Show PHP info"; return ;;
            '?') echo "[?] Help"; return ;;
            q) echo "[q] Quit"; return ;;
            # Vim-style navigation
            k) ((current > 0)) && ((current--)) ;;
            j) ((current < total - 1)) && ((current++)) ;;
        esac
    done
}

print_menu_line() {
    local index="$1"
    local current="$2"
    local text="$3"

    if [[ "$index" -eq "$current" ]]; then
        echo "  ${MAGENTA}▸ ${text}${RESET}"
    else
        echo "    ${text}"
    fi
}

execute_menu_item() {
    local selected="$1"

    clear

    case "$selected" in
        "[u] Switch PHP version")
            cmd_use
            wait_for_key
            ;;
        "[i] Install PHP/extension")
            cmd_install
            wait_for_key
            ;;
        "[l] List installed versions")
            cmd_list
            wait_for_key
            ;;
        "[c] Edit PHP configuration")
            cmd_config
            wait_for_key
            ;;
        "[f] Manage PHP-FPM")
            cmd_fpm
            wait_for_key
            ;;
        "[n] Nginx management")
            cmd_nginx
            wait_for_key
            ;;
        "[s] Start dev server")
            cmd_serve
            wait_for_key
            ;;
        "[g] Log viewer")
            cmd_logs
            wait_for_key
            ;;
        "[o] Show PHP info")
            cmd_info
            wait_for_key
            ;;
        "[?] Help")
            show_help
            wait_for_key
            ;;
        "[q] Quit")
            return 1
            ;;
    esac

    return 0
}

wait_for_key() {
    echo ""
    gum style --foreground 241 "Press any key to continue..."
    read -rsn1
}

fallback_menu() {
    local framework
    framework=$(detect_framework 2>/dev/null)

    while true; do
        clear
        print_header

        echo ""
        echo "${BOLD}─── Version Management ───${RESET}"
        echo "  1) Switch PHP version"
        echo "  2) Install PHP/extension"
        echo "  3) List versions"
        echo ""
        echo "${BOLD}─── Configuration ───${RESET}"
        echo "  4) Edit PHP config"
        echo "  5) Manage PHP-FPM"
        echo "  6) Nginx management"
        echo ""
        echo "${BOLD}─── Development ───${RESET}"
        echo "  7) Start dev server"
        echo "  8) Log viewer"
        echo ""
        echo "${BOLD}─── Other ───${RESET}"
        echo "  9) Show PHP info"
        echo "  h) Help"
        echo "  q) Quit"
        echo ""

        local choice
        read -rp "Select [1-9/h/q]: " choice

        case "$choice" in
            1) cmd_use; read -rp "Press Enter to continue..." ;;
            2) cmd_install; read -rp "Press Enter to continue..." ;;
            3) cmd_list; read -rp "Press Enter to continue..." ;;
            4) cmd_config; read -rp "Press Enter to continue..." ;;
            5) cmd_fpm; read -rp "Press Enter to continue..." ;;
            6) cmd_nginx; read -rp "Press Enter to continue..." ;;
            7) cmd_serve; read -rp "Press Enter to continue..." ;;
            8) cmd_logs ;;
            9) cmd_info; read -rp "Press Enter to continue..." ;;
            h|H) show_help; read -rp "Press Enter to continue..." ;;
            q|Q) clear; break ;;
        esac
    done
}

# === nginx.sh ===


nginx_is_installed() {
    command_exists nginx
}

nginx_get_version() {
    nginx -v 2>&1 | grep -oE '[0-9]+\.[0-9]+\.[0-9]+'
}

nginx_repo_configured() {
    local pm=$(get_package_manager)

    case "$pm" in
        apt)
            [[ -f /etc/apt/sources.list.d/nginx.list ]] || \
            grep -rq "nginx.org" /etc/apt/sources.list.d/ 2>/dev/null
            ;;
        dnf|yum)
            [[ -f /etc/yum.repos.d/nginx.repo ]]
            ;;
        *)
            return 1
            ;;
    esac
}

nginx_setup_repo() {
    local pm=$(get_package_manager)

    info_log "Setting up official nginx repository..."

    case "$pm" in
        apt)
            # Install prerequisites (suppress tmpfiles warnings in containers)
            run_privileged apt-get update -qq 2>/dev/null
            run_privileged apt-get install -y curl gnupg2 ca-certificates lsb-release 2>&1 | grep -v "tmpfiles.d" || true

            # Add nginx signing key
            curl -fsSL https://nginx.org/keys/nginx_signing.key | \
                run_privileged gpg --dearmor -o /usr/share/keyrings/nginx-archive-keyring.gpg 2>/dev/null

            # Detect codename
            local codename
            if [[ -f /etc/os-release ]]; then
                . /etc/os-release
                case "$ID" in
                    ubuntu) codename="${UBUNTU_CODENAME:-$(lsb_release -cs 2>/dev/null || echo 'jammy')}" ;;
                    debian) codename="${VERSION_CODENAME:-$(lsb_release -cs 2>/dev/null || echo 'bookworm')}" ;;
                    *) codename="jammy" ;;
                esac
            else
                codename="jammy"
            fi

            # Add repository
            echo "deb [signed-by=/usr/share/keyrings/nginx-archive-keyring.gpg] http://nginx.org/packages/mainline/${ID:-ubuntu} $codename nginx" | \
                run_privileged tee /etc/apt/sources.list.d/nginx.list > /dev/null

            # Pin nginx packages from official repo
            run_privileged tee /etc/apt/preferences.d/99nginx > /dev/null <<EOF
Package: *
Pin: origin nginx.org
Pin: release o=nginx
Pin-Priority: 900
EOF

            run_privileged apt-get update -qq
            success "Nginx official repository configured"
            ;;
        dnf|yum)
            # Detect OS version
            local releasever
            if [[ -f /etc/os-release ]]; then
                . /etc/os-release
                releasever="${VERSION_ID%%.*}"
            else
                releasever="8"
            fi

            # Create nginx repo file
            run_privileged tee /etc/yum.repos.d/nginx.repo > /dev/null <<EOF
[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/\$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/\$basearch/
gpgcheck=1
enabled=0
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
EOF
            success "Nginx official repository configured"
            ;;
        *)
            error "Unsupported package manager for nginx repository setup"
            return 1
            ;;
    esac
}

nginx_install() {
    local pm=$(get_package_manager)

    if nginx_is_installed; then
        local version
        version=$(nginx_get_version)
        warn "Nginx is already installed (v${version})"

        if ! gum_confirm "Reinstall/upgrade nginx?"; then
            return 0
        fi
    fi

    # Setup official repo if not configured
    if ! nginx_repo_configured; then
        if gum_confirm "Setup official nginx repository? (recommended for latest version)"; then
            nginx_setup_repo || return 1
        fi
    fi

    info_log "Installing nginx..."

    case "$pm" in
        apt)
            # Suppress tmpfiles warnings in containers
            run_privileged apt-get install -y nginx 2>&1 | grep -v "tmpfiles.d" || true
            ;;
        dnf)
            run_privileged dnf install -y nginx 2>&1 | grep -v "tmpfiles.d" || true
            ;;
        yum)
            run_privileged yum install -y nginx 2>&1 | grep -v "tmpfiles.d" || true
            ;;
        *)
            error "Unsupported package manager: $pm"
            return 1
            ;;
    esac

    if nginx_is_installed; then
        local version
        version=$(nginx_get_version)
        success "Nginx installed (v${version})"

        # Enable and start nginx
        if gum_confirm "Start nginx now?"; then
            run_privileged systemctl enable nginx 2>/dev/null || true
            run_privileged systemctl start nginx
            success "Nginx started"
        fi
        return 0
    else
        error "Nginx installation failed"
        return 1
    fi
}

nginx_uninstall() {
    if ! nginx_is_installed; then
        warn "Nginx is not installed"
        return 0
    fi

    if ! gum_confirm "Uninstall nginx?" "no"; then
        return 0
    fi

    local pm=$(get_package_manager)

    # Stop service first
    run_privileged systemctl stop nginx 2>/dev/null || true
    run_privileged systemctl disable nginx 2>/dev/null || true

    case "$pm" in
        apt)
            if gum_confirm "Remove configuration files too?" "no"; then
                run_privileged apt-get purge -y nginx nginx-common
            else
                run_privileged apt-get remove -y nginx
            fi
            run_privileged apt-get autoremove -y
            ;;
        dnf|yum)
            run_privileged $pm remove -y nginx
            ;;
    esac

    success "Nginx uninstalled"
}

nginx_ensure_installed() {
    if ! nginx_is_installed; then
        warn "Nginx is not installed"
        if gum_confirm "Install nginx from official repository?"; then
            nginx_install || return 1
        else
            return 1
        fi
    fi
    return 0
}

NGINX_CONF_DIRS=(
    "/etc/nginx/sites-enabled"
    "/etc/nginx/conf.d"
    "/etc/nginx/sites-available"
)

NGINX_TEMPLATE_DIR="${HOME}/.phpvm/nginx-templates"

BACKEND_FPM="php-fpm"
BACKEND_OCTANE_SWOOLE="octane-swoole"
BACKEND_OCTANE_ROADRUNNER="octane-roadrunner"
BACKEND_OCTANE_FRANKENPHP="octane-frankenphp"
BACKEND_SWOOLE="swoole"
BACKEND_ROADRUNNER="roadrunner"
BACKEND_FRANKENPHP="frankenphp"
BACKEND_CUSTOM="custom"
BACKEND_UNKNOWN="unknown"

init_nginx_templates() {
    mkdir -p "$NGINX_TEMPLATE_DIR"
}

find_all_nginx_configs() {
    local project_root="${1:-$PWD}"
    project_root=$(cd "$project_root" 2>/dev/null && pwd)

    local found_configs=()

    for conf_dir in "${NGINX_CONF_DIRS[@]}"; do
        [[ ! -d "$conf_dir" ]] && continue

        while IFS= read -r -d '' conf_file; do
            if grep -q "$project_root" "$conf_file" 2>/dev/null; then
                found_configs+=("$conf_file")
            fi
        done < <(find "$conf_dir" -type f \( -name "*.conf" -o ! -name "*.*" \) -print0 2>/dev/null)
    done

    printf '%s\n' "${found_configs[@]}"
}

find_nginx_config() {
    local project_root="${1:-$PWD}"
    local all_configs
    all_configs=$(find_all_nginx_configs "$project_root")

    if [[ -z "$all_configs" ]]; then
        return 1
    fi

    local config_count
    config_count=$(echo "$all_configs" | wc -l)

    if [[ "$config_count" -eq 1 ]]; then
        echo "$all_configs"
        return 0
    fi

    # Multiple configs - return first one (use select_nginx_config for interactive)
    echo "$all_configs" | head -1
}

select_nginx_config() {
    local project_root="${1:-$PWD}"
    local all_configs
    all_configs=$(find_all_nginx_configs "$project_root")

    if [[ -z "$all_configs" ]]; then
        error "No nginx configurations found for this project"
        return 1
    fi

    local config_count
    config_count=$(echo "$all_configs" | wc -l)

    if [[ "$config_count" -eq 1 ]]; then
        echo "$all_configs"
        return 0
    fi

    # Multiple configs - let user select
    if [[ "$UI_MODE" == "gum" ]]; then
        local choice
        choice=$(echo "$all_configs" | gum filter \
            --header "Multiple configs found. Select one:" \
            --height 10)
        echo "$choice"
    else
        echo "Multiple nginx configurations found:"
        local i=1
        while IFS= read -r config; do
            echo "  $i) $config"
            ((i++))
        done <<< "$all_configs"

        local choice
        read -rp "Select config (1-$config_count): " choice

        echo "$all_configs" | sed -n "${choice}p"
    fi
}

parse_server_name() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && return 1

    grep -oP 'server_name\s+\K[^;]+' "$config_file" 2>/dev/null | head -1 | tr -d ' '
}

parse_listen_port() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && return 1

    local port
    port=$(grep -oP 'listen\s+\K\d+' "$config_file" 2>/dev/null | head -1)
    echo "${port:-80}"
}

parse_access_log() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && return 1

    local log_path
    log_path=$(grep -oP 'access_log\s+\K[^\s;]+' "$config_file" 2>/dev/null | head -1)

    if [[ -n "$log_path" && "$log_path" != "off" ]]; then
        echo "$log_path"
    else
        echo "/var/log/nginx/access.log"
    fi
}

parse_error_log() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && return 1

    local log_path
    log_path=$(grep -oP 'error_log\s+\K[^\s;]+' "$config_file" 2>/dev/null | head -1)

    if [[ -n "$log_path" && "$log_path" != "off" ]]; then
        echo "$log_path"
    else
        echo "/var/log/nginx/error.log"
    fi
}

detect_backend_type() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && echo "$BACKEND_UNKNOWN" && return 1

    local config_content
    config_content=$(cat "$config_file")

    # Check for FrankenPHP
    if echo "$config_content" | grep -qE 'proxy_pass.*:8443|proxy_pass.*frankenphp'; then
        echo "$BACKEND_FRANKENPHP"
        return 0
    fi

    # Check for RoadRunner
    if echo "$config_content" | grep -qE 'proxy_pass.*:8080|proxy_pass.*roadrunner'; then
        echo "$BACKEND_ROADRUNNER"
        return 0
    fi

    # Check for Swoole/Octane
    if echo "$config_content" | grep -qE 'proxy_pass.*:(8000|9501)|proxy_pass.*swoole|proxy_pass.*octane'; then
        if is_framework_project && [[ "$(detect_framework)" == "laravel" ]] && has_octane 2>/dev/null; then
            local octane_driver
            octane_driver=$(get_octane_driver)
            case "$octane_driver" in
                swoole) echo "$BACKEND_OCTANE_SWOOLE" ;;
                roadrunner) echo "$BACKEND_OCTANE_ROADRUNNER" ;;
                frankenphp) echo "$BACKEND_OCTANE_FRANKENPHP" ;;
                *) echo "$BACKEND_SWOOLE" ;;
            esac
            return 0
        fi
        echo "$BACKEND_SWOOLE"
        return 0
    fi

    # Check for PHP-FPM
    if echo "$config_content" | grep -qE 'fastcgi_pass'; then
        echo "$BACKEND_FPM"
        return 0
    fi

    echo "$BACKEND_UNKNOWN"
    return 1
}

get_octane_driver() {
    if [[ -f ".env" ]]; then
        local driver
        driver=$(grep -oP 'OCTANE_SERVER=\K\w+' .env 2>/dev/null)
        [[ -n "$driver" ]] && echo "$driver" && return 0
    fi

    if [[ -f "config/octane.php" ]]; then
        local driver
        driver=$(grep -oP "'server'\s*=>\s*\K\w+" "config/octane.php" 2>/dev/null | head -1)
        [[ -n "$driver" ]] && echo "$driver" && return 0
    fi

    echo "swoole"
}

parse_fpm_backend() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && return 1

    grep -oP 'fastcgi_pass\s+\K[^;]+' "$config_file" 2>/dev/null | head -1 | tr -d ' '
}

parse_proxy_backend() {
    local config_file="$1"
    [[ ! -f "$config_file" ]] && return 1

    grep -oP 'proxy_pass\s+\K[^;]+' "$config_file" 2>/dev/null | head -1 | tr -d ' '
}

get_backend_display_name() {
    local backend_type="$1"

    case "$backend_type" in
        "$BACKEND_FPM") echo "PHP-FPM" ;;
        "$BACKEND_OCTANE_SWOOLE") echo "Laravel Octane (Swoole)" ;;
        "$BACKEND_OCTANE_ROADRUNNER") echo "Laravel Octane (RoadRunner)" ;;
        "$BACKEND_OCTANE_FRANKENPHP") echo "Laravel Octane (FrankenPHP)" ;;
        "$BACKEND_SWOOLE") echo "Swoole" ;;
        "$BACKEND_ROADRUNNER") echo "RoadRunner" ;;
        "$BACKEND_FRANKENPHP") echo "FrankenPHP" ;;
        "$BACKEND_CUSTOM") echo "Custom" ;;
        *) echo "Unknown" ;;
    esac
}


get_fpm_pools() {
    local pools=()

    # Check for FPM sockets
    for socket in /var/run/php/php*-fpm*.sock /run/php/php*-fpm*.sock; do
        [[ -S "$socket" ]] && pools+=("unix:$socket")
    done

    # Check for FPM TCP ports (common: 9000, 9001, etc.)
    for port in 9000 9001 9002 9003; do
        if netstat -tuln 2>/dev/null | grep -q ":$port " || \
           ss -tuln 2>/dev/null | grep -q ":$port "; then
            pools+=("127.0.0.1:$port")
        fi
    done

    printf '%s\n' "${pools[@]}" | sort -u
}

get_fpm_pools_for_version() {
    local version="$1"
    local pools=()

    # Socket pattern for version
    for socket in /var/run/php/php${version}-fpm*.sock /run/php/php${version}-fpm*.sock; do
        [[ -S "$socket" ]] && pools+=("unix:$socket")
    done

    printf '%s\n' "${pools[@]}"
}

select_fpm_pool() {
    local pools
    pools=$(get_fpm_pools)

    if [[ -z "$pools" ]]; then
        warn "No PHP-FPM pools found"
        local custom
        custom=$(gum_input "Enter custom FPM socket/address:" "unix:/var/run/php/php-fpm.sock")
        echo "$custom"
        return
    fi

    if [[ "$UI_MODE" == "gum" ]]; then
        local options=()
        while IFS= read -r pool; do
            options+=("$pool")
        done <<< "$pools"
        options+=("Custom...")

        local choice
        choice=$(printf '%s\n' "${options[@]}" | gum filter \
            --header "Select PHP-FPM pool:" \
            --height 10)

        if [[ "$choice" == "Custom..." ]]; then
            gum_input "Enter custom FPM socket/address:" "unix:/var/run/php/php-fpm.sock"
        else
            echo "$choice"
        fi
    else
        echo "Available PHP-FPM pools:"
        local i=1
        while IFS= read -r pool; do
            echo "  $i) $pool"
            ((i++))
        done <<< "$pools"
        echo "  $i) Custom..."

        local choice
        read -rp "Select pool: " choice

        local pool_count
        pool_count=$(echo "$pools" | wc -l)

        if [[ "$choice" -gt "$pool_count" ]]; then
            read -rp "Enter custom FPM socket/address: " custom
            echo "$custom"
        else
            echo "$pools" | sed -n "${choice}p"
        fi
    fi
}


get_project_supervisor_services() {
    local project_root="${1:-$PWD}"
    local project_id
    project_id=$(get_project_id "$project_root" 2>/dev/null)

    if [[ -z "$project_id" ]]; then
        return 1
    fi

    # Find supervisor configs for this project
    local configs=()
    for conf in /etc/supervisor/conf.d/${project_id}*.conf; do
        [[ -f "$conf" ]] && configs+=("$conf")
    done

    if [[ ${#configs[@]} -eq 0 ]]; then
        return 1
    fi

    # Extract program names and ports
    for conf in "${configs[@]}"; do
        local program
        program=$(grep -oP '\[program:\K[^\]]+' "$conf" 2>/dev/null)

        # Try to detect port from command
        local port
        port=$(grep -oP 'port[=:]\s*\K\d+|--port[=\s]+\K\d+|-p\s+\K\d+' "$conf" 2>/dev/null | head -1)

        if [[ -n "$program" ]]; then
            if [[ -n "$port" ]]; then
                echo "$program|$port"
            else
                echo "$program|8000"  # Default port
            fi
        fi
    done
}

select_supervisor_service() {
    local services
    services=$(get_project_supervisor_services)

    if [[ -z "$services" ]]; then
        return 1
    fi

    local options=()
    local ports=()

    while IFS='|' read -r name port; do
        options+=("$name (port $port)")
        ports+=("$port")
    done <<< "$services"

    if [[ "$UI_MODE" == "gum" ]]; then
        local choice
        choice=$(printf '%s\n' "${options[@]}" | gum filter \
            --header "Select supervisor service:" \
            --height 10)

        # Extract port from choice
        echo "$choice" | grep -oP 'port \K\d+'
    else
        echo "Available supervisor services:"
        local i=1
        for opt in "${options[@]}"; do
            echo "  $i) $opt"
            ((i++))
        done

        local choice
        read -rp "Select service: " choice
        echo "${ports[$((choice-1))]}"
    fi
}


is_octane_running() {
    pgrep -f "artisan octane" &>/dev/null || \
    pgrep -f "swoole" &>/dev/null || \
    pgrep -f "roadrunner" &>/dev/null || \
    pgrep -f "frankenphp" &>/dev/null
}

get_running_backends() {
    local backends=()

    # Check Swoole
    if pgrep -f "swoole" &>/dev/null; then
        local pid port
        pid=$(pgrep -f "swoole" | head -1)
        port=$(ss -tlnp 2>/dev/null | grep "pid=$pid" | grep -oP ':\K\d+' | head -1)
        backends+=("Swoole|$pid|${port:-N/A}")
    fi

    # Check RoadRunner
    if pgrep -f "roadrunner\|rr " &>/dev/null; then
        local pid port
        pid=$(pgrep -f "roadrunner\|rr " | head -1)
        port=$(ss -tlnp 2>/dev/null | grep "pid=$pid" | grep -oP ':\K\d+' | head -1)
        backends+=("RoadRunner|$pid|${port:-N/A}")
    fi

    # Check FrankenPHP
    if pgrep -f "frankenphp" &>/dev/null; then
        local pid port
        pid=$(pgrep -f "frankenphp" | head -1)
        port=$(ss -tlnp 2>/dev/null | grep "pid=$pid" | grep -oP ':\K\d+' | head -1)
        backends+=("FrankenPHP|$pid|${port:-N/A}")
    fi

    # Check Octane
    if pgrep -f "artisan octane" &>/dev/null; then
        local pid port
        pid=$(pgrep -f "artisan octane" | head -1)
        port=$(ss -tlnp 2>/dev/null | grep "pid=$pid" | grep -oP ':\K\d+' | head -1)
        backends+=("Octane|$pid|${port:-N/A}")
    fi

    printf '%s\n' "${backends[@]}"
}

show_backend_processes() {
    local backends
    backends=$(get_running_backends)

    if [[ -z "$backends" ]]; then
        echo "No backend processes running"
        return 1
    fi

    echo "${BOLD}Running Backend Processes${RESET}"
    echo ""
    printf "  %-15s %-10s %-10s\n" "BACKEND" "PID" "PORT"
    echo "  ----------------------------------------"

    while IFS='|' read -r name pid port; do
        printf "  %-15s %-10s %-10s\n" "$name" "$pid" "$port"
    done <<< "$backends"
}


nginx_status() {
    if command -v systemctl &>/dev/null; then
        systemctl is-active nginx 2>/dev/null
    elif command -v service &>/dev/null; then
        service nginx status &>/dev/null && echo "active" || echo "inactive"
    else
        pgrep -x nginx &>/dev/null && echo "active" || echo "inactive"
    fi
}

nginx_reload() {
    info_log "Reloading nginx..."

    if ! run_privileged nginx -t 2>/dev/null; then
        error "Nginx configuration test failed"
        return 1
    fi

    if command -v systemctl &>/dev/null; then
        run_privileged systemctl reload nginx
    elif command -v service &>/dev/null; then
        run_privileged service nginx reload
    else
        run_privileged nginx -s reload
    fi

    [[ $? -eq 0 ]] && success "Nginx reloaded" || { error "Failed to reload nginx"; return 1; }
}

nginx_restart() {
    info_log "Restarting nginx..."

    if command -v systemctl &>/dev/null; then
        run_privileged systemctl restart nginx
    elif command -v service &>/dev/null; then
        run_privileged service nginx restart
    else
        run_privileged nginx -s stop
        sleep 1
        run_privileged nginx
    fi

    [[ $? -eq 0 ]] && success "Nginx restarted" || { error "Failed to restart nginx"; return 1; }
}


generate_laravel_template() {
    local server_name="$1"
    local port="$2"
    local root_path="$3"
    local backend="$4"
    local backend_type="$5"

    local fastcgi_or_proxy=""

    if [[ "$backend_type" == "$BACKEND_FPM" ]]; then
        fastcgi_or_proxy="
        location ~ \\.php\$ {
            fastcgi_pass $backend;
            fastcgi_param SCRIPT_FILENAME \$realpath_root\$fastcgi_script_name;
            include fastcgi_params;
            fastcgi_hide_header X-Powered-By;
        }"
    else
        local proxy_port="${backend##*:}"
        fastcgi_or_proxy="
        location / {
            proxy_pass http://127.0.0.1:$proxy_port;
            proxy_http_version 1.1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
            proxy_set_header Upgrade \$http_upgrade;
            proxy_set_header Connection \"upgrade\";
            proxy_read_timeout 60s;
            proxy_buffering off;
        }"
    fi

    cat << EOF
server {
    listen $port;
    listen [::]:$port;
    server_name $server_name;
    root $root_path/public;

    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-Content-Type-Options "nosniff";

    index index.php;

    charset utf-8;

    location / {
        try_files \$uri \$uri/ /index.php?\$query_string;
    }

    location = /favicon.ico { access_log off; log_not_found off; }
    location = /robots.txt  { access_log off; log_not_found off; }

    error_page 404 /index.php;
$fastcgi_or_proxy

    location ~ /\\.(?!well-known).* {
        deny all;
    }

    access_log /var/log/nginx/${server_name}-access.log;
    error_log /var/log/nginx/${server_name}-error.log;
}
EOF
}

generate_symfony_template() {
    local server_name="$1"
    local port="$2"
    local root_path="$3"
    local backend="$4"
    local backend_type="$5"

    local fastcgi_or_proxy=""

    if [[ "$backend_type" == "$BACKEND_FPM" ]]; then
        fastcgi_or_proxy="
        location ~ ^/index\\.php(/|\$) {
            fastcgi_pass $backend;
            fastcgi_split_path_info ^(.+\\.php)(/.*)$;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME \$realpath_root\$fastcgi_script_name;
            fastcgi_param DOCUMENT_ROOT \$realpath_root;
            internal;
        }

        location ~ \\.php\$ {
            return 404;
        }"
    else
        local proxy_port="${backend##*:}"
        fastcgi_or_proxy="
        location / {
            proxy_pass http://127.0.0.1:$proxy_port;
            proxy_http_version 1.1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }"
    fi

    cat << EOF
server {
    listen $port;
    listen [::]:$port;
    server_name $server_name;
    root $root_path/public;

    location / {
        try_files \$uri /index.php\$is_args\$args;
    }
$fastcgi_or_proxy

    access_log /var/log/nginx/${server_name}-access.log;
    error_log /var/log/nginx/${server_name}-error.log;
}
EOF
}

generate_yii_template() {
    local server_name="$1"
    local port="$2"
    local root_path="$3"
    local backend="$4"
    local backend_type="$5"

    local fastcgi_or_proxy=""

    if [[ "$backend_type" == "$BACKEND_FPM" ]]; then
        fastcgi_or_proxy="
        location ~ \\.php\$ {
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
            fastcgi_pass $backend;
            try_files \$uri =404;
        }"
    else
        local proxy_port="${backend##*:}"
        fastcgi_or_proxy="
        location / {
            proxy_pass http://127.0.0.1:$proxy_port;
            proxy_http_version 1.1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }"
    fi

    cat << EOF
server {
    listen $port;
    listen [::]:$port;
    server_name $server_name;
    root $root_path/web;
    index index.php;

    charset utf-8;

    location / {
        try_files \$uri \$uri/ /index.php?\$args;
    }

    location ~ ^/assets/.*\\.php\$ {
        deny all;
    }
$fastcgi_or_proxy

    location ~ /\\.(ht|svn|git) {
        deny all;
    }

    access_log /var/log/nginx/${server_name}-access.log;
    error_log /var/log/nginx/${server_name}-error.log;
}
EOF
}

generate_generic_template() {
    local server_name="$1"
    local port="$2"
    local root_path="$3"
    local backend="$4"
    local backend_type="$5"

    local fastcgi_or_proxy=""

    if [[ "$backend_type" == "$BACKEND_FPM" ]]; then
        fastcgi_or_proxy="
        location ~ \\.php\$ {
            fastcgi_pass $backend;
            fastcgi_param SCRIPT_FILENAME \$document_root\$fastcgi_script_name;
            include fastcgi_params;
        }"
    else
        local proxy_port="${backend##*:}"
        fastcgi_or_proxy="
        location / {
            proxy_pass http://127.0.0.1:$proxy_port;
            proxy_http_version 1.1;
            proxy_set_header Host \$host;
            proxy_set_header X-Real-IP \$remote_addr;
            proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto \$scheme;
        }"
    fi

    cat << EOF
server {
    listen $port;
    listen [::]:$port;
    server_name $server_name;
    root $root_path;
    index index.php index.html;

    location / {
        try_files \$uri \$uri/ /index.php?\$query_string;
    }
$fastcgi_or_proxy

    location ~ /\\. {
        deny all;
    }

    access_log /var/log/nginx/${server_name}-access.log;
    error_log /var/log/nginx/${server_name}-error.log;
}
EOF
}


list_custom_templates() {
    init_nginx_templates

    local templates
    templates=$(find "$NGINX_TEMPLATE_DIR" -maxdepth 1 -name "*.conf" -type f 2>/dev/null)

    if [[ -z "$templates" ]]; then
        echo "No custom templates found"
        echo "Templates directory: $NGINX_TEMPLATE_DIR"
        return 1
    fi

    echo "${BOLD}Custom Nginx Templates${RESET}"
    echo ""

    while IFS= read -r template; do
        local name
        name=$(basename "$template" .conf)
        echo "  - $name"
    done <<< "$templates"
}

add_custom_template() {
    init_nginx_templates

    local name
    name=$(gum_input "Template name:" "my-template")

    [[ -z "$name" ]] && return

    local template_file="$NGINX_TEMPLATE_DIR/${name}.conf"

    if [[ -f "$template_file" ]]; then
        if ! gum_confirm "Template '$name' exists. Overwrite?"; then
            return
        fi
    fi

    local editor="${EDITOR:-nano}"

    # Create template with placeholder
    cat > "$template_file" << 'EOF'

server {
    listen {{PORT}};
    listen [::]:{{PORT}};
    server_name {{SERVER_NAME}};
    root {{ROOT_PATH}}/public;

    # Add your configuration here

    access_log /var/log/nginx/{{SERVER_NAME}}-access.log;
    error_log /var/log/nginx/{{SERVER_NAME}}-error.log;
}
EOF

    "$editor" "$template_file"

    if [[ -f "$template_file" ]]; then
        success "Template saved: $name"
    fi
}

edit_custom_template() {
    init_nginx_templates

    local templates
    templates=$(find "$NGINX_TEMPLATE_DIR" -maxdepth 1 -name "*.conf" -type f 2>/dev/null)

    if [[ -z "$templates" ]]; then
        error "No custom templates found"
        return 1
    fi

    local options=()
    while IFS= read -r template; do
        options+=("$(basename "$template" .conf)")
    done <<< "$templates"

    local choice
    choice=$(printf '%s\n' "${options[@]}" | gum filter \
        --header "Select template to edit:" \
        --height 10)

    [[ -z "$choice" ]] && return

    local editor="${EDITOR:-nano}"
    "$editor" "$NGINX_TEMPLATE_DIR/${choice}.conf"
}

delete_custom_template() {
    init_nginx_templates

    local templates
    templates=$(find "$NGINX_TEMPLATE_DIR" -maxdepth 1 -name "*.conf" -type f 2>/dev/null)

    if [[ -z "$templates" ]]; then
        error "No custom templates found"
        return 1
    fi

    local options=()
    while IFS= read -r template; do
        options+=("$(basename "$template" .conf)")
    done <<< "$templates"

    local choice
    choice=$(printf '%s\n' "${options[@]}" | gum filter \
        --header "Select template to delete:" \
        --height 10)

    [[ -z "$choice" ]] && return

    if gum_confirm "Delete template '$choice'?"; then
        rm -f "$NGINX_TEMPLATE_DIR/${choice}.conf"
        success "Template deleted"
    fi
}

use_custom_template() {
    local template_name="$1"
    local server_name="$2"
    local port="$3"
    local root_path="$4"
    local backend="$5"

    local template_file="$NGINX_TEMPLATE_DIR/${template_name}.conf"

    if [[ ! -f "$template_file" ]]; then
        error "Template not found: $template_name"
        return 1
    fi

    cat "$template_file" | \
        sed "s|{{SERVER_NAME}}|$server_name|g" | \
        sed "s|{{PORT}}|$port|g" | \
        sed "s|{{ROOT_PATH}}|$root_path|g" | \
        sed "s|{{BACKEND}}|$backend|g"
}


generate_nginx_config() {
    local project_root="${1:-$PWD}"
    project_root=$(cd "$project_root" && pwd)

    local project_name
    project_name=$(basename "$project_root")

    echo "${BOLD}Nginx Configuration Generator${RESET}"
    echo ""

    # Server name
    local server_name
    server_name=$(gum_input "Server name (domain):" "${project_name}.local")

    [[ -z "$server_name" ]] && return

    # Listen port
    local port
    if [[ "$UI_MODE" == "gum" ]]; then
        port=$(gum choose --header "Listen port:" "80" "8080" "443" "Custom...")
        if [[ "$port" == "Custom..." ]]; then
            port=$(gum_input "Enter port:" "80")
        fi
    else
        read -rp "Listen port [80]: " port
        port="${port:-80}"
    fi

    # Listen IP
    local listen_ip
    if [[ "$UI_MODE" == "gum" ]]; then
        listen_ip=$(gum choose --header "Listen IP:" "*" "127.0.0.1" "0.0.0.0")
    else
        read -rp "Listen IP [*]: " listen_ip
        listen_ip="${listen_ip:-*}"
    fi

    # Backend type selection
    local backend_choice
    if [[ "$UI_MODE" == "gum" ]]; then
        local backend_options=("PHP-FPM" "Supervisor Service" "Custom Proxy")

        # Check for available options
        local supervisor_services
        supervisor_services=$(get_project_supervisor_services 2>/dev/null)
        [[ -z "$supervisor_services" ]] && backend_options=("PHP-FPM" "Custom Proxy")

        backend_choice=$(printf '%s\n' "${backend_options[@]}" | gum filter \
            --header "Select backend type:" \
            --height 8)
    else
        echo "Backend type:"
        echo "  1) PHP-FPM"
        echo "  2) Supervisor Service"
        echo "  3) Custom Proxy"
        read -rp "Select [1]: " bc
        case "$bc" in
            2) backend_choice="Supervisor Service" ;;
            3) backend_choice="Custom Proxy" ;;
            *) backend_choice="PHP-FPM" ;;
        esac
    fi

    local backend=""
    local backend_type=""

    case "$backend_choice" in
        "PHP-FPM")
            backend=$(select_fpm_pool)
            backend_type="$BACKEND_FPM"
            ;;
        "Supervisor Service")
            local service_port
            service_port=$(select_supervisor_service)
            if [[ -n "$service_port" ]]; then
                backend="127.0.0.1:$service_port"
                backend_type="$BACKEND_CUSTOM"
            else
                backend=$(gum_input "Enter proxy address:" "127.0.0.1:8000")
                backend_type="$BACKEND_CUSTOM"
            fi
            ;;
        "Custom Proxy")
            backend=$(gum_input "Enter proxy address:" "127.0.0.1:8000")
            backend_type="$BACKEND_CUSTOM"
            ;;
    esac

    [[ -z "$backend" ]] && return

    # Template selection
    local template_choice
    local framework
    framework=$(detect_framework 2>/dev/null)

    # Build template options
    local template_options=()
    case "$framework" in
        laravel) template_options+=("Laravel (recommended)") ;;
        symfony) template_options+=("Symfony (recommended)") ;;
        yii) template_options+=("Yii (recommended)") ;;
    esac
    template_options+=("Generic PHP")

    # Add custom templates
    local custom_templates
    custom_templates=$(find "$NGINX_TEMPLATE_DIR" -maxdepth 1 -name "*.conf" -type f 2>/dev/null | while read -r t; do basename "$t" .conf; done)
    if [[ -n "$custom_templates" ]]; then
        while IFS= read -r ct; do
            template_options+=("Custom: $ct")
        done <<< "$custom_templates"
    fi

    if [[ "$UI_MODE" == "gum" ]]; then
        template_choice=$(printf '%s\n' "${template_options[@]}" | gum filter \
            --header "Select template:" \
            --height 10)
    else
        echo "Template:"
        local i=1
        for opt in "${template_options[@]}"; do
            echo "  $i) $opt"
            ((i++))
        done
        read -rp "Select [1]: " tc
        template_choice="${template_options[$((tc-1))]}"
    fi

    # Generate config
    local config=""
    case "$template_choice" in
        "Laravel"*) config=$(generate_laravel_template "$server_name" "$port" "$project_root" "$backend" "$backend_type") ;;
        "Symfony"*) config=$(generate_symfony_template "$server_name" "$port" "$project_root" "$backend" "$backend_type") ;;
        "Yii"*) config=$(generate_yii_template "$server_name" "$port" "$project_root" "$backend" "$backend_type") ;;
        "Custom: "*)
            local custom_name="${template_choice#Custom: }"
            config=$(use_custom_template "$custom_name" "$server_name" "$port" "$project_root" "$backend")
            ;;
        *) config=$(generate_generic_template "$server_name" "$port" "$project_root" "$backend" "$backend_type") ;;
    esac

    # Adjust listen directive for IP
    if [[ "$listen_ip" != "*" ]]; then
        config=$(echo "$config" | sed "s/listen $port;/listen ${listen_ip}:${port};/g")
        config=$(echo "$config" | sed "s/listen \[::\]:$port;/listen [::1]:${port};/g")
    fi

    # Preview config
    echo ""
    echo "${BOLD}Generated Configuration:${RESET}"
    echo "----------------------------------------"
    echo "$config"
    echo "----------------------------------------"
    echo ""

    # Save location
    local save_location
    if [[ "$UI_MODE" == "gum" ]]; then
        save_location=$(gum choose \
            --header "Save to:" \
            "/etc/nginx/sites-available/${server_name}.conf" \
            "/etc/nginx/conf.d/${server_name}.conf" \
            "Print to stdout only" \
            "Cancel")
    else
        echo "Save to:"
        echo "  1) /etc/nginx/sites-available/${server_name}.conf"
        echo "  2) /etc/nginx/conf.d/${server_name}.conf"
        echo "  3) Print to stdout only"
        echo "  4) Cancel"
        read -rp "Select [1]: " sl
        case "$sl" in
            2) save_location="/etc/nginx/conf.d/${server_name}.conf" ;;
            3) save_location="Print to stdout only" ;;
            4) save_location="Cancel" ;;
            *) save_location="/etc/nginx/sites-available/${server_name}.conf" ;;
        esac
    fi

    case "$save_location" in
        "Cancel"|"")
            return
            ;;
        "Print to stdout only")
            echo "$config"
            return
            ;;
        *)
            echo "$config" | run_privileged tee "$save_location" > /dev/null

            if [[ $? -eq 0 ]]; then
                success "Configuration saved: $save_location"

                # Enable site if in sites-available
                if [[ "$save_location" == "/etc/nginx/sites-available/"* ]]; then
                    local site_name
                    site_name=$(basename "$save_location")
                    local enabled_link="/etc/nginx/sites-enabled/$site_name"

                    if [[ ! -e "$enabled_link" ]]; then
                        if gum_confirm "Enable site?"; then
                            run_privileged ln -sf "$save_location" "$enabled_link"
                            success "Site enabled"
                        fi
                    fi
                fi

                # Test and reload nginx
                if gum_confirm "Test and reload nginx?"; then
                    if run_privileged nginx -t; then
                        nginx_reload
                    else
                        error "Configuration test failed. Please fix errors before reloading."
                    fi
                fi

                # Add to /etc/hosts
                if gum_confirm "Add '$server_name' to /etc/hosts?"; then
                    if ! grep -q "$server_name" /etc/hosts 2>/dev/null; then
                        echo "127.0.0.1 $server_name" | run_privileged tee -a /etc/hosts > /dev/null
                        success "Added to /etc/hosts"
                    else
                        warn "$server_name already in /etc/hosts"
                    fi
                fi
            else
                error "Failed to save configuration"
            fi
            ;;
    esac
}


show_nginx_info() {
    local project_root="${1:-$PWD}"

    local all_configs
    all_configs=$(find_all_nginx_configs "$project_root")

    if [[ -z "$all_configs" ]]; then
        warn "No nginx configuration found for this project"
        echo ""
        echo "Searched directories:"
        for dir in "${NGINX_CONF_DIRS[@]}"; do
            echo "  - $dir"
        done
        echo ""
        echo "Run 'php nginx generate' to create a configuration"
        return 1
    fi

    local config_count
    config_count=$(echo "$all_configs" | wc -l)

    echo ""
    echo "${BOLD}Nginx Configuration${RESET}"

    if [[ "$config_count" -gt 1 ]]; then
        echo "  ${YELLOW}Multiple configs found ($config_count)${RESET}"
    fi

    while IFS= read -r config_file; do
        local server_name port backend_type
        server_name=$(parse_server_name "$config_file")
        port=$(parse_listen_port "$config_file")
        backend_type=$(detect_backend_type "$config_file")

        echo ""
        echo "  ${CYAN}Config:${RESET} $config_file"
        echo "  Server name: ${server_name:-N/A}"
        echo "  Listen port: $port"
        echo "  Backend:     $(get_backend_display_name "$backend_type")"

        case "$backend_type" in
            "$BACKEND_FPM")
                local fpm_backend
                fpm_backend=$(parse_fpm_backend "$config_file")
                echo "  FPM Socket:  ${fpm_backend:-N/A}"
                ;;
            *)
                local proxy_backend
                proxy_backend=$(parse_proxy_backend "$config_file")
                [[ -n "$proxy_backend" ]] && echo "  Proxy:       $proxy_backend"
                ;;
        esac
    done <<< "$all_configs"

    echo ""
    echo "${BOLD}Nginx Status${RESET}"
    local status
    status=$(nginx_status)
    if [[ "$status" == "active" ]]; then
        echo "  Service: ${GREEN}running${RESET}"
    else
        echo "  Service: ${RED}stopped${RESET}"
    fi

    # Show running backends
    echo ""
    show_backend_processes

    echo ""
    echo "${BOLD}Log Files${RESET}"
    local first_config
    first_config=$(echo "$all_configs" | head -1)
    echo "  Access: $(parse_access_log "$first_config")"
    echo "  Error:  $(parse_error_log "$first_config")"
}

view_nginx_config() {
    local config_file
    config_file=$(select_nginx_config)

    [[ -z "$config_file" ]] && return

    if [[ "$UI_MODE" == "gum" ]]; then
        cat "$config_file" | gum pager
    else
        less "$config_file"
    fi
}


cmd_nginx() {
    # Always show interactive menu
    interactive_nginx_menu
}

interactive_nginx_menu() {
    # Check if nginx is installed first
    if ! nginx_is_installed; then
        echo ""
        warn "Nginx is not installed"
        echo ""
        if gum_confirm "Install nginx from official repository?"; then
            nginx_install
        fi
        return
    fi

    while true; do
        clear

        # Show nginx status header
        local version status_text
        version=$(nginx_get_version)
        if systemctl is-active nginx &>/dev/null 2>&1; then
            status_text="${GREEN}running${RESET}"
        else
            status_text="${RED}stopped${RESET}"
        fi

        echo "${BOLD}Nginx v${version}${RESET} - ${status_text}"
        echo ""

        local choice
        choice=$(gum choose \
            "Show Configuration Info" \
            "View Configuration" \
            "Edit Configuration" \
            "Generate New Config" \
            "Service Control" \
            "Test Configuration" \
            "Show Backend Processes" \
            "Manage Templates" \
            "Uninstall Nginx" \
            "Back")

        case "$choice" in
            "Show Configuration Info")
                show_nginx_info
                read -rp "Press Enter to continue..."
                ;;
            "View Configuration")
                view_nginx_config
                ;;
            "Edit Configuration")
                local config_file
                config_file=$(select_nginx_config)
                [[ -n "$config_file" ]] && run_privileged "${EDITOR:-nano}" "$config_file"
                ;;
            "Generate New Config")
                generate_nginx_config
                read -rp "Press Enter to continue..."
                ;;
            "Service Control")
                local svc_action
                svc_action=$(gum choose \
                    "Start" \
                    "Stop" \
                    "Restart" \
                    "Reload" \
                    "Enable on boot" \
                    "Disable on boot" \
                    "Back")
                case "$svc_action" in
                    "Start") run_privileged systemctl start nginx && success "Nginx started" ;;
                    "Stop") run_privileged systemctl stop nginx && success "Nginx stopped" ;;
                    "Restart") nginx_restart ;;
                    "Reload") nginx_reload ;;
                    "Enable on boot") run_privileged systemctl enable nginx && success "Nginx enabled" ;;
                    "Disable on boot") run_privileged systemctl disable nginx && success "Nginx disabled" ;;
                esac
                [[ "$svc_action" != "Back" && -n "$svc_action" ]] && read -rp "Press Enter to continue..."
                ;;
            "Test Configuration")
                run_privileged nginx -t
                read -rp "Press Enter to continue..."
                ;;
            "Show Backend Processes")
                show_backend_processes
                read -rp "Press Enter to continue..."
                ;;
            "Manage Templates")
                manage_templates_menu
                ;;
            "Uninstall Nginx")
                nginx_uninstall
                [[ ! nginx_is_installed ]] && break
                read -rp "Press Enter to continue..."
                ;;
            "Back"|"")
                break
                ;;
        esac
    done
}

manage_templates_menu() {
    while true; do
        clear
        echo "${BOLD}Nginx Template Management${RESET}"
        echo ""

        local choice
        choice=$(gum choose \
            "List Templates" \
            "Add Template" \
            "Edit Template" \
            "Delete Template" \
            "Back")

        case "$choice" in
            "List Templates")
                list_custom_templates
                read -rp "Press Enter to continue..."
                ;;
            "Add Template")
                add_custom_template
                ;;
            "Edit Template")
                edit_custom_template
                ;;
            "Delete Template")
                delete_custom_template
                ;;
            "Back"|"")
                break
                ;;
        esac
    done
}

# === logs.sh ===

DEFAULT_TAIL_LINES=50
LOG_VIEWER_LEFT_WIDTH=30

has_ripgrep() {
    command -v rg &>/dev/null
}

has_grep() {
    command -v grep &>/dev/null
}

ensure_search_tool() {
    if has_ripgrep; then
        return 0
    fi

    if has_grep; then
        warn "ripgrep not found, using grep (slower)"
        return 0
    fi

    # Offer to install ripgrep
    echo "No search tool found (ripgrep or grep)"
    if gum_confirm "Install ripgrep?"; then
        info_log "Installing ripgrep..."
        case "$DISTRO_FAMILY" in
            debian)
                run_privileged apt-get update
                run_privileged apt-get install -y ripgrep
                ;;
            rhel)
                run_privileged dnf install -y ripgrep 2>/dev/null || \
                run_privileged yum install -y ripgrep
                ;;
            *)
                error "Cannot auto-install ripgrep on this platform"
                echo "Please install manually: https://github.com/BurntSushi/ripgrep"
                return 1
                ;;
        esac

        if has_ripgrep; then
            success "ripgrep installed"
            return 0
        else
            error "Failed to install ripgrep"
            return 1
        fi
    fi

    return 1
}

get_framework_log_dir() {
    local framework
    framework=$(detect_framework 2>/dev/null)

    case "$framework" in
        laravel)
            echo "storage/logs"
            ;;
        symfony)
            echo "var/log"
            ;;
        yii)
            echo "runtime/logs"
            ;;
        *)
            return 1
            ;;
    esac
}

get_framework_logs() {
    local log_dir
    log_dir=$(get_framework_log_dir)

    if [[ -z "$log_dir" || ! -d "$log_dir" ]]; then
        return 1
    fi

    find "$log_dir" -type f -name "*.log" 2>/dev/null | sort -r
}

get_latest_framework_log() {
    local log_dir
    log_dir=$(get_framework_log_dir)

    if [[ -z "$log_dir" || ! -d "$log_dir" ]]; then
        return 1
    fi

    local framework
    framework=$(detect_framework 2>/dev/null)

    case "$framework" in
        laravel)
            local today_log="$log_dir/laravel-$(date +%Y-%m-%d).log"
            if [[ -f "$today_log" ]]; then
                echo "$today_log"
            elif [[ -f "$log_dir/laravel.log" ]]; then
                echo "$log_dir/laravel.log"
            else
                find "$log_dir" -type f -name "*.log" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-
            fi
            ;;
        symfony)
            local env="${APP_ENV:-dev}"
            if [[ -f "$log_dir/$env.log" ]]; then
                echo "$log_dir/$env.log"
            else
                find "$log_dir" -type f -name "*.log" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-
            fi
            ;;
        yii)
            if [[ -f "$log_dir/app.log" ]]; then
                echo "$log_dir/app.log"
            else
                find "$log_dir" -type f -name "*.log" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-
            fi
            ;;
    esac
}

get_supervisor_log() {
    local project_root="${1:-$PWD}"
    local project_id
    project_id=$(get_project_id "$project_root" 2>/dev/null)

    if [[ -z "$project_id" ]]; then
        return 1
    fi

    local log_file="/var/log/supervisor/${project_id}-worker.log"
    if [[ -f "$log_file" ]]; then
        echo "$log_file"
        return 0
    fi

    find /var/log/supervisor -name "${project_id}*.log" 2>/dev/null | head -1
}

get_all_supervisor_logs() {
    local project_root="${1:-$PWD}"
    local project_id
    project_id=$(get_project_id "$project_root" 2>/dev/null)

    if [[ -z "$project_id" ]]; then
        return 1
    fi

    find /var/log/supervisor -name "${project_id}*.log" 2>/dev/null | sort
}

get_nginx_access_log() {
    local config_file
    config_file=$(find_nginx_config 2>/dev/null)

    if [[ -n "$config_file" ]]; then
        parse_access_log "$config_file"
    else
        echo "/var/log/nginx/access.log"
    fi
}

get_nginx_error_log() {
    local config_file
    config_file=$(find_nginx_config 2>/dev/null)

    if [[ -n "$config_file" ]]; then
        parse_error_log "$config_file"
    else
        echo "/var/log/nginx/error.log"
    fi
}

get_fpm_log() {
    local version
    version=$(get_current_version 2>/dev/null)

    local possible_logs=(
        "/var/log/php${version}-fpm.log"
        "/var/log/php-fpm/www-error.log"
        "/var/log/php-fpm.log"
        "/var/log/php/php${version}-fpm.log"
    )

    for log in "${possible_logs[@]}"; do
        if [[ -f "$log" ]]; then
            echo "$log"
            return 0
        fi
    done

    return 1
}

build_log_tree() {
    local logs=()

    # Nginx logs
    local access_log error_log
    access_log=$(get_nginx_access_log 2>/dev/null)
    error_log=$(get_nginx_error_log 2>/dev/null)

    [[ -f "$access_log" ]] && logs+=("nginx|access|$access_log")
    [[ -f "$error_log" ]] && logs+=("nginx|error|$error_log")

    # Framework logs
    local framework
    framework=$(detect_framework 2>/dev/null)

    if [[ -n "$framework" ]]; then
        local framework_logs
        framework_logs=$(get_framework_logs 2>/dev/null)

        if [[ -n "$framework_logs" ]]; then
            while IFS= read -r log; do
                local name
                name=$(basename "$log")
                logs+=("$framework|$name|$log")
            done <<< "$framework_logs"
        fi
    fi

    # Supervisor logs
    local supervisor_logs
    supervisor_logs=$(get_all_supervisor_logs 2>/dev/null)

    if [[ -n "$supervisor_logs" ]]; then
        while IFS= read -r log; do
            local name
            name=$(basename "$log")
            logs+=("supervisor|$name|$log")
        done <<< "$supervisor_logs"
    fi

    # PHP-FPM log
    local fpm_log
    fpm_log=$(get_fpm_log 2>/dev/null)
    [[ -n "$fpm_log" && -f "$fpm_log" ]] && logs+=("php-fpm|fpm.log|$fpm_log")

    printf '%s\n' "${logs[@]}"
}

resolve_log_path() {
    local log_type="$1"

    case "$log_type" in
        app|framework|laravel|symfony|yii)
            get_latest_framework_log
            ;;
        access|nginx-access)
            get_nginx_access_log
            ;;
        error|nginx-error)
            get_nginx_error_log
            ;;
        worker|supervisor)
            get_supervisor_log
            ;;
        fpm|php-fpm)
            get_fpm_log
            ;;
        all)
            echo "all"
            ;;
        *)
            # Assume it's a file path
            if [[ -f "$log_type" ]]; then
                echo "$log_type"
            else
                return 1
            fi
            ;;
    esac
}

search_logs_rg() {
    local pattern="$1"
    local log_path="$2"
    local lines="${3:-50}"
    local case_insensitive="${4:-true}"

    if [[ ! -f "$log_path" ]]; then
        error "Log file not found: $log_path"
        return 1
    fi

    local search_cmd
    local args=()

    if has_ripgrep; then
        search_cmd="rg"
        args+=(--color=always)
        [[ "$case_insensitive" == "true" ]] && args+=(-i)
        args+=("$pattern" "$log_path")
    else
        search_cmd="grep"
        args+=(--color=always)
        [[ "$case_insensitive" == "true" ]] && args+=(-i)
        args+=("$pattern" "$log_path")
    fi

    if [[ ! -r "$log_path" ]]; then
        run_privileged "$search_cmd" "${args[@]}" | tail -n "$lines"
    else
        "$search_cmd" "${args[@]}" | tail -n "$lines"
    fi
}

parse_laravel_exception() {
    local log_path="$1"
    local lines="${2:-100}"

    if [[ ! -f "$log_path" ]]; then
        return 1
    fi

    # Laravel log format: [YYYY-MM-DD HH:MM:SS] environment.LEVEL: message
    # Exceptions span multiple lines until next timestamp

    local content
    if [[ ! -r "$log_path" ]]; then
        content=$(run_privileged tail -n "$lines" "$log_path")
    else
        content=$(tail -n "$lines" "$log_path")
    fi

    # Group by timestamp entries
    echo "$content" | awk '
    /^\[20[0-9]{2}-[0-9]{2}-[0-9]{2}/ {
        if (entry != "") print entry
        entry = $0
        next
    }
    { entry = entry "\n" $0 }
    END { if (entry != "") print entry }
    '
}

parse_symfony_exception() {
    local log_path="$1"
    local lines="${2:-100}"

    if [[ ! -f "$log_path" ]]; then
        return 1
    fi

    local content
    if [[ ! -r "$log_path" ]]; then
        content=$(run_privileged tail -n "$lines" "$log_path")
    else
        content=$(tail -n "$lines" "$log_path")
    fi

    # Symfony log format: [YYYY-MM-DD HH:MM:SS] channel.LEVEL: message
    echo "$content" | awk '
    /^\[20[0-9]{2}-[0-9]{2}-[0-9]{2}/ {
        if (entry != "") print entry
        entry = $0
        next
    }
    { entry = entry "\n" $0 }
    END { if (entry != "") print entry }
    '
}

parse_yii_exception() {
    local log_path="$1"
    local lines="${2:-100}"

    if [[ ! -f "$log_path" ]]; then
        return 1
    fi

    local content
    if [[ ! -r "$log_path" ]]; then
        content=$(run_privileged tail -n "$lines" "$log_path")
    else
        content=$(tail -n "$lines" "$log_path")
    fi

    # Yii log format varies, but typically starts with timestamp
    echo "$content" | awk '
    /^20[0-9]{2}[-\/][0-9]{2}[-\/][0-9]{2}/ || /^\[20[0-9]{2}/ {
        if (entry != "") print entry
        entry = $0
        next
    }
    { entry = entry "\n" $0 }
    END { if (entry != "") print entry }
    '
}

parse_framework_exceptions() {
    local log_path="$1"
    local lines="${2:-100}"

    local framework
    framework=$(detect_framework 2>/dev/null)

    case "$framework" in
        laravel) parse_laravel_exception "$log_path" "$lines" ;;
        symfony) parse_symfony_exception "$log_path" "$lines" ;;
        yii) parse_yii_exception "$log_path" "$lines" ;;
        *)
            # Generic parsing
            if [[ ! -r "$log_path" ]]; then
                run_privileged tail -n "$lines" "$log_path"
            else
                tail -n "$lines" "$log_path"
            fi
            ;;
    esac
}

filter_logs_by_level() {
    local log_path="$1"
    local level="$2"  # ERROR, WARNING, INFO, DEBUG
    local lines="${3:-100}"

    local pattern
    case "${level^^}" in
        ERROR|ERR) pattern="(ERROR|CRITICAL|EMERGENCY|ALERT)" ;;
        WARNING|WARN) pattern="(WARNING|WARN)" ;;
        INFO) pattern="INFO" ;;
        DEBUG) pattern="DEBUG" ;;
        *) pattern="$level" ;;
    esac

    search_logs_rg "$pattern" "$log_path" "$lines" "false"
}

list_logs_tree() {
    local logs
    logs=$(build_log_tree)

    if [[ -z "$logs" ]]; then
        echo "No logs found"
        return 1
    fi

    echo "${BOLD}Available Logs${RESET}"
    echo ""

    local current_category=""

    while IFS='|' read -r category name path; do
        if [[ "$category" != "$current_category" ]]; then
            current_category="$category"
            echo "${BOLD}${CYAN}$category${RESET}"
        fi

        local size
        size=$(du -h "$path" 2>/dev/null | cut -f1)
        echo "  ├─ ${name} ${DIM}($size)${RESET}"
    done <<< "$logs"
}

interactive_log_viewer() {
    if [[ "$UI_MODE" != "gum" ]]; then
        error "Interactive viewer requires gum"
        echo "Install gum: https://github.com/charmbracelet/gum"
        return 1
    fi

    local logs
    logs=$(build_log_tree)

    if [[ -z "$logs" ]]; then
        error "No logs found"
        return 1
    fi

    # Build selection menu
    local options=()
    local paths=()

    while IFS='|' read -r category name path; do
        options+=("$category/$name")
        paths+=("$path")
    done <<< "$logs"

    while true; do
        clear
        echo "${BOLD}Interactive Log Viewer${RESET}"
        echo "${DIM}Select a log to view, or press Esc to exit${RESET}"
        echo ""

        local choice
        choice=$(printf '%s\n' "${options[@]}" | gum filter \
            --header "Select log:" \
            --height 15 \
            --placeholder "Type to filter...")

        [[ -z "$choice" ]] && break

        # Find the path for selected choice
        local selected_path=""
        for i in "${!options[@]}"; do
            if [[ "${options[$i]}" == "$choice" ]]; then
                selected_path="${paths[$i]}"
                break
            fi
        done

        if [[ -n "$selected_path" ]]; then
            show_log_with_options "$selected_path"
        fi
    done
}

show_log_with_options() {
    local log_path="$1"

    while true; do
        clear
        echo "${BOLD}Log: ${CYAN}$log_path${RESET}"
        echo ""

        local action
        action=$(gum choose \
            "View last 50 lines" \
            "View last 100 lines" \
            "View last 500 lines" \
            "Tail (follow)" \
            "Search" \
            "Filter by level" \
            "Parse exceptions" \
            "Clear log" \
            "Back")

        case "$action" in
            "View last 50 lines")
                show_log_content "$log_path" 50
                ;;
            "View last 100 lines")
                show_log_content "$log_path" 100
                ;;
            "View last 500 lines")
                show_log_content "$log_path" 500
                ;;
            "Tail (follow)")
                follow_single_log "$log_path"
                ;;
            "Search")
                interactive_search "$log_path"
                ;;
            "Filter by level")
                interactive_filter_level "$log_path"
                ;;
            "Parse exceptions")
                show_parsed_exceptions "$log_path"
                ;;
            "Clear log")
                clear_single_log "$log_path"
                ;;
            "Back"|"")
                break
                ;;
        esac
    done
}

show_log_content() {
    local log_path="$1"
    local lines="${2:-50}"

    local content
    if [[ ! -r "$log_path" ]]; then
        content=$(run_privileged tail -n "$lines" "$log_path")
    else
        content=$(tail -n "$lines" "$log_path")
    fi

    if [[ "$UI_MODE" == "gum" ]]; then
        echo "$content" | gum pager
    else
        echo "$content" | less
    fi
}

follow_single_log() {
    local log_path="$1"

    echo ""
    info_log "Following: $log_path"
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    if [[ ! -r "$log_path" ]]; then
        run_privileged tail -f "$log_path"
    else
        tail -f "$log_path"
    fi
}

interactive_search() {
    local log_path="$1"

    ensure_search_tool || return 1

    local pattern
    pattern=$(gum input --placeholder "Enter search pattern...")

    [[ -z "$pattern" ]] && return

    echo ""
    info_log "Searching for: $pattern"
    echo ""

    local results
    results=$(search_logs_rg "$pattern" "$log_path" 100)

    if [[ -n "$results" ]]; then
        echo "$results" | gum pager
    else
        warn "No matches found"
        read -rp "Press Enter to continue..."
    fi
}

interactive_filter_level() {
    local log_path="$1"

    local level
    level=$(gum choose "ERROR" "WARNING" "INFO" "DEBUG" "Custom")

    [[ -z "$level" ]] && return

    if [[ "$level" == "Custom" ]]; then
        level=$(gum input --placeholder "Enter custom level/pattern...")
        [[ -z "$level" ]] && return
    fi

    echo ""
    info_log "Filtering by level: $level"
    echo ""

    local results
    results=$(filter_logs_by_level "$log_path" "$level" 100)

    if [[ -n "$results" ]]; then
        echo "$results" | gum pager
    else
        warn "No matches found"
        read -rp "Press Enter to continue..."
    fi
}

show_parsed_exceptions() {
    local log_path="$1"

    echo ""
    info_log "Parsing exceptions..."
    echo ""

    local results
    results=$(parse_framework_exceptions "$log_path" 200)

    if [[ -n "$results" ]]; then
        echo "$results" | gum pager
    else
        warn "No exceptions found"
        read -rp "Press Enter to continue..."
    fi
}

clear_single_log() {
    local log_path="$1"

    if ! gum_confirm "Clear log file: $log_path?"; then
        return 0
    fi

    if [[ ! -w "$log_path" ]]; then
        run_privileged truncate -s 0 "$log_path"
    else
        truncate -s 0 "$log_path"
    fi

    if [[ $? -eq 0 ]]; then
        success "Log cleared"
    else
        error "Failed to clear log"
    fi

    read -rp "Press Enter to continue..."
}

split_screen_viewer() {
    if ! command -v tmux &>/dev/null; then
        error "Split screen requires tmux"
        echo "Install tmux: sudo apt install tmux"
        return 1
    fi

    local logs
    logs=$(build_log_tree)

    if [[ -z "$logs" ]]; then
        error "No logs found"
        return 1
    fi

    # Build selection menu
    local options=()
    local paths=()

    while IFS='|' read -r category name path; do
        options+=("$category/$name")
        paths+=("$path")
    done <<< "$logs"

    echo "${BOLD}Split Screen Log Viewer${RESET}"
    echo ""

    # Select first log
    echo "Select log for ${CYAN}LEFT${RESET} pane:"
    local left_choice
    left_choice=$(printf '%s\n' "${options[@]}" | gum filter \
        --header "Select left log:" \
        --height 10)

    [[ -z "$left_choice" ]] && return

    local left_path=""
    for i in "${!options[@]}"; do
        if [[ "${options[$i]}" == "$left_choice" ]]; then
            left_path="${paths[$i]}"
            break
        fi
    done

    # Select second log
    echo ""
    echo "Select log for ${CYAN}RIGHT${RESET} pane:"
    local right_choice
    right_choice=$(printf '%s\n' "${options[@]}" | gum filter \
        --header "Select right log:" \
        --height 10)

    [[ -z "$right_choice" ]] && return

    local right_path=""
    for i in "${!options[@]}"; do
        if [[ "${options[$i]}" == "$right_choice" ]]; then
            right_path="${paths[$i]}"
            break
        fi
    done

    # Start tmux split session
    local session_name="phpvm_logs_$$"

    echo ""
    info_log "Starting split screen viewer..."
    echo "${DIM}Press Ctrl+B then D to detach, or Ctrl+C in both panes to exit${RESET}"
    sleep 1

    # Create tmux session with split panes
    tmux new-session -d -s "$session_name" "tail -f '$left_path'"
    tmux split-window -h -t "$session_name" "tail -f '$right_path'"
    tmux select-layout -t "$session_name" even-horizontal
    tmux attach-session -t "$session_name"

    # Cleanup
    tmux kill-session -t "$session_name" 2>/dev/null
}

follow_all_logs() {
    local logs_to_follow=()

    # Collect all available logs
    local app_log
    app_log=$(get_latest_framework_log 2>/dev/null)
    [[ -n "$app_log" && -f "$app_log" ]] && logs_to_follow+=("$app_log")

    local error_log
    error_log=$(get_nginx_error_log 2>/dev/null)
    [[ -n "$error_log" && -f "$error_log" ]] && logs_to_follow+=("$error_log")

    local supervisor_log
    supervisor_log=$(get_supervisor_log 2>/dev/null)
    [[ -n "$supervisor_log" && -f "$supervisor_log" ]] && logs_to_follow+=("$supervisor_log")

    if [[ ${#logs_to_follow[@]} -eq 0 ]]; then
        error "No log files found to follow"
        return 1
    fi

    info_log "Following ${#logs_to_follow[@]} log files:"
    for log in "${logs_to_follow[@]}"; do
        echo "  - $log"
    done
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    if [[ -r "${logs_to_follow[0]}" ]]; then
        tail -f "${logs_to_follow[@]}"
    else
        run_privileged tail -f "${logs_to_follow[@]}"
    fi
}

list_logs() {
    list_logs_tree
}

show_log() {
    local log_type="${1:-app}"
    local lines="${2:-$DEFAULT_TAIL_LINES}"

    local log_path
    log_path=$(resolve_log_path "$log_type")

    if [[ -z "$log_path" ]]; then
        error "Log type '$log_type' not found"
        echo ""
        echo "Available log types:"
        echo "  app      - Framework log (Laravel/Symfony/Yii)"
        echo "  access   - Nginx access log"
        echo "  error    - Nginx error log"
        echo "  worker   - Supervisor worker log"
        echo "  fpm      - PHP-FPM log"
        return 1
    fi

    if [[ ! -f "$log_path" ]]; then
        error "Log file not found: $log_path"
        return 1
    fi

    if [[ ! -r "$log_path" ]]; then
        run_privileged tail -n "$lines" "$log_path"
    else
        tail -n "$lines" "$log_path"
    fi
}

follow_log() {
    local log_type="${1:-app}"

    if [[ "$log_type" == "all" ]]; then
        follow_all_logs
        return
    fi

    local log_path
    log_path=$(resolve_log_path "$log_type")

    if [[ -z "$log_path" ]]; then
        error "Log type '$log_type' not found"
        return 1
    fi

    if [[ ! -f "$log_path" ]]; then
        error "Log file not found: $log_path"
        return 1
    fi

    info_log "Following: $log_path"
    echo "${DIM}Press Ctrl+C to stop${RESET}"
    echo ""

    if [[ ! -r "$log_path" ]]; then
        run_privileged tail -f "$log_path"
    else
        tail -f "$log_path"
    fi
}

search_logs() {
    local pattern="$1"
    local log_type="${2:-app}"
    local lines="${3:-50}"

    if [[ -z "$pattern" ]]; then
        error "Search pattern required"
        echo "Usage: php logs search <pattern> [log_type] [lines]"
        return 1
    fi

    ensure_search_tool || return 1

    local log_path
    log_path=$(resolve_log_path "$log_type")

    if [[ -z "$log_path" || ! -f "$log_path" ]]; then
        error "Log file not found"
        return 1
    fi

    info_log "Searching in: $log_path"
    echo ""

    search_logs_rg "$pattern" "$log_path" "$lines"
}

clear_log() {
    local log_type="$1"

    if [[ -z "$log_type" ]]; then
        error "Log type required"
        echo "Usage: php logs clear <log_type>"
        return 1
    fi

    local log_path
    log_path=$(resolve_log_path "$log_type")

    if [[ -z "$log_path" || ! -f "$log_path" ]]; then
        error "Log file not found"
        return 1
    fi

    if ! gum_confirm "Clear log file: $log_path?"; then
        return 0
    fi

    if [[ ! -w "$log_path" ]]; then
        run_privileged truncate -s 0 "$log_path"
    else
        truncate -s 0 "$log_path"
    fi

    if [[ $? -eq 0 ]]; then
        success "Log cleared: $log_path"
    else
        error "Failed to clear log"
        return 1
    fi
}

filter_logs() {
    local level="$1"
    local log_type="${2:-app}"
    local lines="${3:-100}"

    if [[ -z "$level" ]]; then
        error "Log level required"
        echo "Usage: php logs filter <level> [log_type] [lines]"
        echo "Levels: ERROR, WARNING, INFO, DEBUG"
        return 1
    fi

    local log_path
    log_path=$(resolve_log_path "$log_type")

    if [[ -z "$log_path" || ! -f "$log_path" ]]; then
        error "Log file not found"
        return 1
    fi

    info_log "Filtering $log_path by level: $level"
    echo ""

    filter_logs_by_level "$log_path" "$level" "$lines"
}

parse_exceptions() {
    local log_type="${1:-app}"
    local lines="${2:-200}"

    local log_path
    log_path=$(resolve_log_path "$log_type")

    if [[ -z "$log_path" || ! -f "$log_path" ]]; then
        error "Log file not found"
        return 1
    fi

    info_log "Parsing exceptions from: $log_path"
    echo ""

    parse_framework_exceptions "$log_path" "$lines"
}

cmd_logs() {
    local subcommand="${1:-}"
    shift 2>/dev/null || true

    # If no subcommand and gum available, show interactive viewer
    if [[ -z "$subcommand" && "$UI_MODE" == "gum" ]]; then
        interactive_log_viewer
        return
    fi

    case "$subcommand" in
        ""|list|ls)
            list_logs
            ;;
        show|cat)
            show_log "$@"
            ;;
        tail|follow|f)
            follow_log "$@"
            ;;
        search|grep)
            search_logs "$@"
            ;;
        filter)
            filter_logs "$@"
            ;;
        parse|exceptions)
            parse_exceptions "$@"
            ;;
        clear)
            clear_log "$@"
            ;;
        split)
            split_screen_viewer
            ;;
        interactive|viewer|ui)
            interactive_log_viewer
            ;;
        *)
            # If subcommand looks like a log type, show it
            local resolved
            resolved=$(resolve_log_path "$subcommand" 2>/dev/null)
            if [[ -n "$resolved" ]]; then
                show_log "$subcommand" "$@"
            else
                echo "Usage: php logs [command] [options]"
                echo ""
                echo "Commands:"
                echo "  (none)            Interactive log viewer (with gum)"
                echo "  list              List available logs"
                echo "  show <type>       Show last N lines (default: 50)"
                echo "  tail <type>       Follow log in real-time"
                echo "  tail all          Follow all logs simultaneously"
                echo "  search <pattern>  Search logs (ripgrep/grep)"
                echo "  filter <level>    Filter by level (ERROR/WARNING/INFO/DEBUG)"
                echo "  parse             Parse and show exceptions"
                echo "  clear <type>      Clear/truncate log file"
                echo "  split             Split screen view (requires tmux)"
                echo "  interactive       Open interactive viewer"
                echo ""
                echo "Log types:"
                echo "  app      - Framework log (Laravel/Symfony/Yii)"
                echo "  access   - Nginx access log"
                echo "  error    - Nginx error log"
                echo "  worker   - Supervisor worker log"
                echo "  fpm      - PHP-FPM log"
                echo "  all      - All logs (for tail command)"
                echo ""
                echo "Examples:"
                echo "  php logs                      # Interactive viewer"
                echo "  php logs list                 # List all logs"
                echo "  php logs show app             # Show last 50 lines"
                echo "  php logs show app 100         # Show last 100 lines"
                echo "  php logs tail app             # Follow app log"
                echo "  php logs tail all             # Follow all logs"
                echo "  php logs split                # Split screen (tmux)"
                echo "  php logs search \"error\" app   # Search for 'error'"
                echo "  php logs filter ERROR app     # Filter ERROR level"
                echo "  php logs parse app            # Parse exceptions"
                echo "  php logs clear app            # Clear app log"
            fi
            ;;
    esac
}

cmd_tail() {
    local log_type="${1:-app}"
    follow_log "$log_type"
}

# === completion.sh ===

generate_bash_completion() {
    cat <<'COMPLETION'

_phpvm_completions() {
    local cur prev words cword
    _get_comp_words_by_ref -n : cur prev words cword

    # Base PHPVM commands
    local base_commands="use install list info config fpm nginx logs tail menu serve worker cron self-update help"

    # Framework detection (cached for performance)
    local framework=""
    if [[ -f "$PWD/artisan" ]]; then
        framework="laravel"
    elif [[ -f "$PWD/bin/console" ]] || [[ -f "$PWD/symfony.lock" ]]; then
        framework="symfony"
    elif [[ -f "$PWD/yii" ]]; then
        framework="yii"
    fi

    case "$cword" in
        1)
            # First argument - main commands
            local commands="$base_commands"

            # Add framework commands if in project
            case "$framework" in
                laravel)
                    commands="$commands artisan"
                    [[ -f "$PWD/composer.json" ]] && grep -q '"laravel/horizon"' "$PWD/composer.json" 2>/dev/null && commands="$commands horizon"
                    ;;
                symfony)
                    commands="$commands console"
                    ;;
                yii)
                    commands="$commands yii"
                    ;;
            esac

            COMPREPLY=($(compgen -W "$commands" -- "$cur"))
            ;;
        2)
            case "${words[1]}" in
                use|install)
                    # PHP versions
                    local versions="8.5 8.4 8.3 8.2 8.1 8.0 7.4 7.3 7.2 7.1 7.0 5.6"
                    if [[ "${words[1]}" == "install" ]]; then
                        versions="$versions extension"
                    fi
                    COMPREPLY=($(compgen -W "$versions" -- "$cur"))
                    ;;
                list)
                    COMPREPLY=($(compgen -W "extensions" -- "$cur"))
                    ;;
                nginx)
                    COMPREPLY=($(compgen -W "info status reload restart config edit test generate processes templates" -- "$cur"))
                    ;;
                logs)
                    COMPREPLY=($(compgen -W "list show tail search filter parse clear split interactive app access error worker fpm" -- "$cur"))
                    ;;
                tail)
                    COMPREPLY=($(compgen -W "app access error worker fpm all" -- "$cur"))
                    ;;
                artisan)
                    # Laravel artisan commands
                    if [[ "$framework" == "laravel" ]]; then
                        local artisan_commands
                        artisan_commands=$(php artisan list --format=txt 2>/dev/null | grep -E '^\s+\S+' | awk '{print $1}' | head -100)
                        COMPREPLY=($(compgen -W "$artisan_commands" -- "$cur"))
                    fi
                    ;;
                console)
                    # Symfony console commands
                    if [[ "$framework" == "symfony" ]]; then
                        local console_commands
                        console_commands=$(php bin/console list --format=txt 2>/dev/null | grep -E '^\s+\S+' | awk '{print $1}' | head -100)
                        COMPREPLY=($(compgen -W "$console_commands" -- "$cur"))
                    fi
                    ;;
                yii)
                    # Yii commands
                    if [[ "$framework" == "yii" ]]; then
                        local yii_commands
                        yii_commands=$(php yii help 2>/dev/null | grep -E '^\s+-' | awk '{print $2}' | head -100)
                        COMPREPLY=($(compgen -W "$yii_commands" -- "$cur"))
                    fi
                    ;;
            esac
            ;;
    esac

    return 0
}

complete -F _phpvm_completions php
COMPLETION
}

generate_zsh_completion() {
    cat <<'COMPLETION'

_phpvm() {
    local curcontext="$curcontext" state line
    typeset -A opt_args

    # Framework detection
    local framework=""
    if [[ -f "$PWD/artisan" ]]; then
        framework="laravel"
    elif [[ -f "$PWD/bin/console" ]] || [[ -f "$PWD/symfony.lock" ]]; then
        framework="symfony"
    elif [[ -f "$PWD/yii" ]]; then
        framework="yii"
    fi

    local base_commands=(
        'use:Switch PHP version'
        'install:Install PHP version or extension'
        'list:List installed PHP versions'
        'info:Show PHP information'
        'config:Edit PHP configuration'
        'fpm:Manage PHP-FPM'
        'nginx:Manage nginx configuration'
        'logs:View and manage logs'
        'tail:Follow logs in real-time'
        'menu:Interactive menu'
        'serve:Start development server'
        'worker:Manage queue workers'
        'cron:Manage scheduled tasks'
        'self-update:Update PHPVM'
        'help:Show help'
    )

    # Add framework commands
    case "$framework" in
        laravel)
            base_commands+=('artisan:Run artisan command')
            [[ -f "$PWD/composer.json" ]] && grep -q '"laravel/horizon"' "$PWD/composer.json" 2>/dev/null && base_commands+=('horizon:Start Horizon')
            ;;
        symfony)
            base_commands+=('console:Run console command')
            ;;
        yii)
            base_commands+=('yii:Run yii command')
            ;;
    esac

    _arguments -C \
        '1: :->command' \
        '*: :->args'

    case $state in
        command)
            _describe -t commands 'php command' base_commands
            ;;
        args)
            case $words[2] in
                use|install)
                    local versions=(8.5 8.4 8.3 8.2 8.1 8.0 7.4 7.3 7.2 7.1 7.0 5.6)
                    [[ $words[2] == "install" ]] && versions+=(extension)
                    _describe -t versions 'PHP version' versions
                    ;;
                list)
                    _describe -t args 'list option' '(extensions)'
                    ;;
                nginx)
                    local nginx_cmds=(info status reload restart config edit test generate processes templates)
                    _describe -t commands 'nginx command' nginx_cmds
                    ;;
                logs)
                    local logs_cmds=(list show tail search filter parse clear split interactive app access error worker fpm)
                    _describe -t commands 'logs command' logs_cmds
                    ;;
                tail)
                    local log_types=(app access error worker fpm all)
                    _describe -t types 'log type' log_types
                    ;;
                artisan)
                    if [[ "$framework" == "laravel" ]]; then
                        local -a artisan_commands
                        artisan_commands=(${(f)"$(php artisan list --format=txt 2>/dev/null | grep -E '^\s+\S+' | awk '{print $1}' | head -100)"})
                        _describe -t commands 'artisan command' artisan_commands
                    fi
                    ;;
                console)
                    if [[ "$framework" == "symfony" ]]; then
                        local -a console_commands
                        console_commands=(${(f)"$(php bin/console list --format=txt 2>/dev/null | grep -E '^\s+\S+' | awk '{print $1}' | head -100)"})
                        _describe -t commands 'console command' console_commands
                    fi
                    ;;
                yii)
                    if [[ "$framework" == "yii" ]]; then
                        local -a yii_commands
                        yii_commands=(${(f)"$(php yii help 2>/dev/null | grep -E '^\s+-' | awk '{print $2}' | head -100)"})
                        _describe -t commands 'yii command' yii_commands
                    fi
                    ;;
            esac
            ;;
    esac
}

compdef _phpvm php
COMPLETION
}

cmd_completion() {
    local shell="$1"

    case "$shell" in
        bash)
            generate_bash_completion
            ;;
        zsh)
            generate_zsh_completion
            ;;
        *)
            echo "Usage: php completion [bash|zsh]"
            echo ""
            echo "Enable completions:"
            echo "  Bash: source <(php completion bash)"
            echo "  Zsh:  source <(php completion zsh)"
            echo ""
            echo "To persist, add to your shell rc file:"
            echo "  echo 'source <(php completion bash)' >> ~/.bashrc"
            echo "  echo 'source <(php completion zsh)' >> ~/.zshrc"
            ;;
    esac
}

# === self_update.sh ===

cmd_self_update() {
    info_log "Checking for updates..."

    local current_version="$PHPVM_VERSION"
    local latest_info

    # Fetch latest release info from GitHub
    latest_info=$(curl -fsSL "$PHPVM_GITHUB_API" 2>/dev/null)

    if [[ -z "$latest_info" ]]; then
        error "Failed to check for updates"
        echo "Could not connect to GitHub API"
        return 1
    fi

    local latest_version
    latest_version=$(echo "$latest_info" | grep -oE '"tag_name":\s*"v?[0-9]+\.[0-9]+\.[0-9]+"' | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)

    if [[ -z "$latest_version" ]]; then
        error "Could not determine latest version"
        return 1
    fi

    echo ""
    echo "${BOLD}Current version:${RESET} $current_version"
    echo "${BOLD}Latest version:${RESET}  $latest_version"
    echo ""

    if version_gte "$current_version" "$latest_version"; then
        success "You are already running the latest version!"
        return 0
    fi

    # Show changelog if available
    local changelog
    changelog=$(echo "$latest_info" | grep -oE '"body":\s*"[^"]*"' | sed 's/"body":\s*"//' | sed 's/"$//' | head -20)

    if [[ -n "$changelog" ]]; then
        echo "${BOLD}Changelog:${RESET}"
        echo "$changelog" | sed 's/\\n/\n/g' | head -10
        echo ""
    fi

    if ! gum_confirm "Update to v${latest_version}?"; then
        msg "Update cancelled"
        return
    fi

    info_log "Downloading update..."

    local tmp_dir
    tmp_dir=$(mktemp -d)

    # Download the installer script
    local installer_url="${PHPVM_RAW_URL}/src/install.sh"

    if ! curl -fsSL -o "${tmp_dir}/install.sh" "$installer_url"; then
        error "Failed to download installer"
        rm -rf "$tmp_dir"
        return 1
    fi

    info_log "Running installer..."

    # Determine current installation mode
    local install_mode="user"
    if [[ -f "/usr/local/bin/php" ]]; then
        install_mode="system"
    fi

    # Run installer with appropriate mode
    if [[ "$install_mode" == "system" ]]; then
        run_privileged bash "${tmp_dir}/install.sh" --upgrade
    else
        bash "${tmp_dir}/install.sh" --upgrade --user
    fi

    rm -rf "$tmp_dir"

    success "Updated to v${latest_version}!"
    echo ""
    echo "Please restart your shell or run: source ~/.bashrc"
}

# === help.sh ===

show_quick_usage() {
    print_header

    cat <<EOF
${BOLD}Usage:${RESET} php [command] [options]

${BOLD}Commands:${RESET}
  use [version]       Switch PHP version
  install [version]   Install PHP version or extension
  list                List installed versions
  menu                Interactive dashboard
  help                Show full help

${DIM}Run 'php help' for all commands${RESET}
EOF
}

show_help() {
    local framework
    framework=$(detect_framework 2>/dev/null)

    print_header

    cat <<EOF
${BOLD}Usage:${RESET} php [command] [options]

${BOLD}Version Management:${RESET}
  use [version]       Switch PHP version (interactive if no version)
  install [version]   Install PHP version or extension
  list                List installed PHP versions
  list extensions     List extensions for current PHP

${BOLD}Information:${RESET}
  info                Show PHPVM, PHP info, and version resolution
  menu                Interactive dashboard menu

${BOLD}Configuration:${RESET}
  config              Edit PHP configuration files
  fpm                 Manage PHP-FPM services and pools
  nginx               Manage nginx (interactive menu)

${BOLD}Logs:${RESET}
  logs                Interactive log viewer (with gum)
  logs list           List available logs
  logs show <type>    Show log content
  logs tail <type>    Follow log in real-time
  logs split          Split-screen log viewer (tmux)
  logs search <pat>   Search logs (ripgrep)
  logs filter <lvl>   Filter by level (ERROR/WARNING/INFO)
  logs parse          Parse framework exceptions
  tail [type]         Shortcut for logs tail
EOF

    cat <<EOF

${BOLD}Development:${RESET}
  serve [options]     Start development server (auto-detect framework)
                      --host HOST   Bind to host (default: 0.0.0.0)
                      --port PORT   Listen on port (default: 8000)
                      --dir DIR     Document root (default: auto-detect)
                      --octane      Use Laravel Octane (Laravel only)
                      Shorthand: 8080, :8080, 10.0.0.1:8080
  worker              Manage queue workers (Supervisor)
  cron                Manage scheduled tasks (Crontab)
EOF

    cat <<EOF

${BOLD}Maintenance:${RESET}
  self-update         Update PHPVM to latest version
  completion [shell]  Generate shell completion (bash/zsh)
  help                Show this help message

${BOLD}Pass-through:${RESET}
  php [args]          Any other arguments pass to PHP binary
  php -v              Show PHP version (pass-through)
  php script.php      Execute PHP script

${BOLD}Composer:${RESET}
  composer [args]     Run Composer with current PHP version

${BOLD}Version Resolution Order:${RESET}
  1. PHPVERSION_USE environment variable (session)
  2. .phpversion file (local, searches up from current directory)
  3. ~/.phpvm/version (user default)
  4. /etc/phpvm/version (system default)
  5. First installed version (fallback)

${BOLD}Examples:${RESET}
  php use 8.4              # Switch to PHP 8.4
  php install 8.3          # Install PHP 8.3
  php install extension    # Install extension (fuzzy search)
  php menu                 # Open interactive dashboard
  php serve                # Start dev server (auto-detect framework)
  php serve 8080           # Start on port 8080 (localhost)
  php serve :3000          # Start on port 3000 (all interfaces)
  php serve --octane       # Start with Laravel Octane
  php logs                 # Interactive log viewer
  php tail app             # Follow application log
  echo "8.4" > .phpversion # Set project PHP version

${BOLD}Tab Completion:${RESET}
  source <(php completion bash)  # Enable bash completion
  source <(php completion zsh)   # Enable zsh completion

${BOLD}More Info:${RESET}
  GitHub: https://github.com/${PHPVM_REPO}
EOF
}

# === Main ===
# Quick check if command is PHPVM command (for performance)
is_phpvm_command() {
    case "$1" in
        use|install|list|info|config|fpm|menu|serve|worker|cron|nginx|logs|tail|completion|self-update|selfupdate|update|help|--help|-h)
            return 0
            ;;
        artisan|console|yii|horizon|octane)
            # Framework commands - only if in project directory
            is_framework_project && return 0
            return 1
            ;;
        *)
            return 1
            ;;
    esac
}

main() {
    # Fast path: if no args or not a PHPVM command, minimal initialization
    if [[ $# -eq 0 ]]; then
        setup_colors
        detect_distro
        set_ui_mode
        show_quick_usage
        exit 0
    fi

    local command="$1"

    # Fast pass-through for PHP execution (minimal overhead)
    if ! is_phpvm_command "$command"; then
        # Direct pass-through to PHP binary
        local php_binary
        php_binary=$(get_php_binary 2>/dev/null)
        if [[ -z "$php_binary" || ! -x "$php_binary" ]]; then
            setup_colors
            error "No PHP version installed"
            echo "Run 'php install' to install PHP"
            exit 1
        fi
        exec "$php_binary" "$@"
    fi

    # Full initialization for PHPVM commands
    setup_colors
    detect_distro
    set_ui_mode

    shift

    case "$command" in
        # Version management
        use)
            init_phpvm
            cmd_use "$@"
            ;;
        install)
            init_phpvm
            cmd_install "$@"
            ;;
        list)
            init_phpvm
            cmd_list "$@"
            ;;

        # Information
        info)
            init_phpvm
            cmd_info
            ;;

        # Configuration
        config)
            init_phpvm
            cmd_config
            ;;
        fpm)
            init_phpvm
            cmd_fpm
            ;;

        # Interactive menu
        menu)
            init_phpvm
            cmd_menu
            ;;

        # Framework commands (only available in project directories)
        serve)
            init_phpvm
            cmd_serve
            ;;
        worker)
            init_phpvm
            cmd_worker
            ;;
        cron)
            init_phpvm
            cmd_cron
            ;;

        # Nginx management
        nginx)
            init_phpvm
            cmd_nginx "$@"
            ;;

        # Log management
        logs)
            init_phpvm
            cmd_logs "$@"
            ;;
        tail)
            init_phpvm
            cmd_tail "$@"
            ;;

        # Framework-specific pass-through
        artisan)
            init_phpvm
            run_artisan "$@"
            ;;
        console)
            init_phpvm
            run_console "$@"
            ;;
        yii)
            init_phpvm
            run_yii "$@"
            ;;
        horizon)
            init_phpvm
            run_horizon_cmd
            ;;
        octane)
            init_phpvm
            run_octane_cmd "$@"
            ;;

        # Tab completion
        completion)
            cmd_completion "$@"
            ;;

        # Maintenance
        self-update|selfupdate|update)
            cmd_self_update
            ;;

        # Help
        help|--help|-h)
            show_help
            ;;
    esac
}

# Framework command runners
run_artisan() {
    if [[ ! -f "artisan" ]]; then
        error "Not in a Laravel project directory"
        return 1
    fi
    local php_bin
    php_bin=$(get_php_binary)
    exec "$php_bin" artisan "$@"
}

run_console() {
    if [[ ! -f "bin/console" ]]; then
        error "Not in a Symfony project directory"
        return 1
    fi
    local php_bin
    php_bin=$(get_php_binary)
    exec "$php_bin" bin/console "$@"
}

run_yii() {
    if [[ ! -f "yii" ]]; then
        error "Not in a Yii project directory"
        return 1
    fi
    local php_bin
    php_bin=$(get_php_binary)
    exec "$php_bin" yii "$@"
}

run_horizon_cmd() {
    if [[ ! -f "artisan" ]]; then
        error "Not in a Laravel project directory"
        return 1
    fi
    if ! has_horizon; then
        error "Laravel Horizon is not installed"
        echo "Install with: composer require laravel/horizon"
        return 1
    fi
    local php_bin
    php_bin=$(get_php_binary)
    exec "$php_bin" artisan horizon
}

run_octane_cmd() {
    if [[ ! -f "artisan" ]]; then
        error "Not in a Laravel project directory"
        return 1
    fi
    if ! has_octane; then
        error "Laravel Octane is not installed"
        echo "Install with: composer require laravel/octane"
        return 1
    fi
    local php_bin
    php_bin=$(get_php_binary)
    if [[ $# -eq 0 ]]; then
        exec "$php_bin" artisan octane:start
    else
        exec "$php_bin" artisan "octane:$1" "${@:2}"
    fi
}

main "$@"
